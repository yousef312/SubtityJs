{"version":3,"file":"subtity.umd.min.js","sources":["../src/subtity.js"],"sourcesContent":["\r\n/**\r\n * Subtity.js 3.1.0\r\n *\r\n * Copyright 2021, yousef neji\r\n * Licensed under the MIT license.\r\n */\r\n/**\r\n * @tutorial\r\n * How to use this library?\r\n * First this library is basically created to used through a rendering process, means for exmaple\r\n * you are rendering a video using a CanvasRenderingContext2d and you want to add subtitles, so you\r\n * can simplye instantiate the class then init it using setUp2D method passing the canvas element or the \r\n * context to render to, then you add the line `Subtity.update()` inside the rendering loop. and that's it\r\n * you can later on use the method `subtity.add()` to add new subtitle passing the text content of the file\r\n * and the extension and the title of the subtitle that going to identify it.\r\n * The system will store any parse subtitle and later on you can switch between using the method `use` passing \r\n * the special title of the subtitle.\r\n */\r\n\r\nlet nums = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\r\n\r\n/**\r\n * A powerfull tool to add subtitles to your movie, it works in two modes, either rendering\r\n * the subtitles to a CanvasRenderingContext2D or directly to the DOM, the style of the text\r\n * is fully accessible to be manipulated using the standard methods defined by the library.\r\n * \r\n * The interface support parsing this files formats:\r\n *  - `webvtt`\r\n *  - `itt`\r\n *  - `ssa`\r\n *  - `srt`\r\n *  - `sbv`\r\n *  - `usf`\r\n *  - `lrc`\r\n *  - `xml`\r\n *  - `rt`\r\n *  - `dfxp`\r\n *  - `ttml`\r\n *  - `subti` official\r\n * \r\n * and exporting this file\r\n *  - `srt`\r\n *  - `subti`\r\n *  - `lrc`\r\n *  - `webvtt`\r\n *  - `ssa`\r\n * @author Yousef Neji\r\n */\r\nclass Subtity {\r\n\r\n    /**\r\n     * Holds the different defined subtitles\r\n     * @type {Array}\r\n     */\r\n    subs = [];\r\n\r\n    /**\r\n     * The currently used subtitle title used it identify it\r\n     * @type {string}\r\n     */\r\n    title = '';\r\n\r\n    /**\r\n     * The text content of the subtitle file currently under use.\r\n     * @readonly\r\n     * @type {string}\r\n     */\r\n    text = '';\r\n\r\n    /**\r\n     * Holds the different subtitles strings for file currently under use. \r\n     * @type {array}\r\n     */\r\n    subtitles = [];\r\n\r\n    /**\r\n     * Holds the different subtitle ranges of time for file currently under use.\r\n     * @type {array}\r\n     */\r\n    ranges = [];\r\n\r\n    /**\r\n     * Holds the current displayed subtitle index in the subtitles list.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    current = 0;\r\n\r\n    /**\r\n     * Holds the subtitles counts for file currently under use.\r\n     * @type {number}\r\n     */\r\n    subtitlesCounts = null;\r\n\r\n    /**\r\n     * Optional offseting of subtitles ranges, used to synchronous the subtitle with the speech\r\n     * when it's asynchronous.\r\n     * @type {number}\r\n     */\r\n    offset = 0;\r\n\r\n    /**\r\n     * Holds the different rendering style options, to change those options use `set` method and\r\n     * don't change them manually as there is extra calculation need to be done.\r\n     */\r\n    style = {\r\n        family: 'Arial',\r\n        size: 19,\r\n        style: 'normal',\r\n        lineSpacing: 5,\r\n        variant: 'normal',\r\n        color: 'rgb(255,255,255)',\r\n        align: 'center',\r\n        direction: 'ltr',\r\n        outlineColor: 'rgb(0,0,0)',\r\n        outlineSize: 1,\r\n        shadowColor: 'rgba(0,0,0,0)',\r\n        opacity: 1,\r\n        shadowBlur: 0,\r\n        shadowX: 0,\r\n        shadowY: 0,\r\n        base: 90,\r\n        left: 50,\r\n        weight: ''\r\n    };\r\n\r\n    /**\r\n     * Used to render the subtitle if 2D renderer was chosen, will remain null if html div container was chosen!\r\n     * @type {CanvasRenderingContext2D}\r\n     */\r\n    renderer = null;\r\n\r\n    /**\r\n     * Used to holds the HTMLElement used to contain the subtitles, will remain null if 2D was chosen!\r\n     * @type {HTMLElement}\r\n     */\r\n    container = null;\r\n\r\n    /**\r\n     * Holds some meta data if any about the subtitle currently under use.\r\n     * @type {object}\r\n     */\r\n    meta = {};\r\n\r\n    /**\r\n     * The displaying mode, holds the mode id used in rendering/displaying the subtitles.\r\n     * \r\n     *  - `1` : for HTMLElement displaying mode\r\n     *  - `2` : for 2DCanvasRendering context mode\r\n     * @readonly\r\n     * @type {number}\r\n     */\r\n    mode = null;\r\n\r\n    /**\r\n     * The HTMLVideoElement used to show the video with subtitles.\r\n     * @type {HTMLVideoElement}\r\n     */\r\n    video = null;\r\n\r\n    /**\r\n     * The Parser owned context, used to perform some critical calculations\r\n     * @type {CanvasRenderingContext2D}\r\n     */\r\n    ctx = document.createElement('canvas').getContext('2d');\r\n\r\n    /**\r\n     * Flag determine whether the subtitle displaying currently activated or not\r\n     * @type {boolean}\r\n     */\r\n    activated = false;\r\n\r\n    /**\r\n     * Holds the current used subtitle file format or extension\r\n     * @type {String}\r\n     */\r\n    currentFileType = null;\r\n\r\n    /**\r\n     * This value controls the speed of the subtitles you can change through `Subtity.setSpeed`.\r\n     * @type {number}\r\n     */\r\n    speedFactor = 1;\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Reset the system by freeing the currently used subtitle list and ranges..\r\n     */\r\n    reset() {\r\n        this.current = 0;\r\n        this.speedFactor = 1;\r\n        this.offset = 0;\r\n        this.style = {\r\n            family: 'Arial',\r\n            size: 19,\r\n            style: 'normal',\r\n            variant: 'normal',\r\n            lineSpacing: 10,\r\n            color: 'rgb(255,255,255)',\r\n            align: 'center',\r\n            direction: 'ltr',\r\n            outlineColor: 'rgb(0,0,0)',\r\n            outlineSize: 1,\r\n            shadowColor: 'rgba(0,0,0,0)',\r\n            shadowBlur: 0,\r\n            opacity: 1,\r\n            shadowX: 0,\r\n            shadowY: 0,\r\n            base: 90,\r\n            left: 50,\r\n            weight: ''\r\n        };\r\n        this.subtitles = [];\r\n        this.ranges = [];\r\n        this.activated = false;\r\n        this.subtitlesCounts = 0;\r\n        this.meta = {};\r\n        this.title = '';\r\n        this.currentFileType = null;\r\n    }\r\n    /**\r\n     * Use certain subtitle file and activate the rendering\r\n     * @param {string} title \r\n     */\r\n    use(title) {\r\n        let i = this.subs.findIndex(a => a.title === title);\r\n        if (i === -1) return;\r\n\r\n        if (this.title !== '') {\r\n            let j = this.subs.findIndex(a => a.title === this.title);\r\n            this.subs[j].used = false;\r\n        }\r\n\r\n        this.current = 0;\r\n\r\n        this.reset();\r\n        this.subs[i].used = true;\r\n        this.title = this.subs[i].title;\r\n        this.ranges = this.subs[i].ranges;\r\n        this.subtitles = this.subs[i].subtitles;\r\n        this.text = this.subs[i].text;\r\n        this.subtitlesCounts = this.subs[i].count;\r\n        this.activated = true;\r\n        this.meta = this.subs[i].meta;\r\n        this.currentFileType = this.subs[i].type;\r\n\r\n        this.calcFontHeight();\r\n    }\r\n    /**\r\n     * Parse the given srt file text content, must be called once after starting the video!\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseSRT(text, title, movie) {\r\n        let sections = text.split('\\n'),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                ranges: [],\r\n                meta: {},\r\n                subtitles: [],\r\n                text: text,\r\n                count: 0,\r\n                type: 'srt'\r\n            },\r\n            // that's all it is\r\n            isNam = false,\r\n            subtitle = [];\r\n        for (let i = 0; i < sections.length; i++) {\r\n            const line = sections[i];\r\n\r\n            if ((line.length == 1 || line.length === 0) && subtitle.length !== 0) {\r\n                isNam = false;\r\n                sub.subtitles.push(subtitle);\r\n                subtitle = [];\r\n            }\r\n\r\n            if (line.indexOf('-->') !== -1) {\r\n                sub.ranges.push(this.getSeconds(line));\r\n                isNam = true;\r\n            }\r\n            else if (isNam === true && line.length !== 1) {\r\n                subtitle.push(line)\r\n            }\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    }\r\n    /**\r\n     * Parse the given xml based file formats text content like `.dfxp` and `.ttml`, must be called once after starting the video!\r\n     * \r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseXMLBased(text, title, movie) {\r\n        let sections = text.split('<body>')[1].split('</body>')[0].split('</div>'),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {\r\n                    langs: {}\r\n                },\r\n                ranges: [],\r\n                subtitles: [],\r\n                text: text,\r\n                type: 'dfxp'\r\n            }, lang = null,\r\n            rang = null,\r\n            flang = null,\r\n            rangout = null;\r\n\r\n        for (let i = 0; i < sections.length; i++) {\r\n            const element = sections[i].split('<div ')[1];\r\n            if (element === undefined) continue;\r\n\r\n            let keyword = element.substring(0, element.indexOf('>')).split(' ');\r\n\r\n            keyword.forEach((a, i) => {\r\n                keyword[i] = keyword[i].split('=');\r\n                if (keyword[i][0] === 'xml:lang') {\r\n                    lang = keyword[i][1].replaceAll('\"', '');\r\n                    if (flang === null) flang = lang;\r\n                    sub.meta.langs[lang] = [];\r\n                }\r\n            });\r\n\r\n            let lines = element.split('</p>');\r\n            if (lang === null) {\r\n                lang = 'en';\r\n                if (flang === null) flang = lang;\r\n            }\r\n            for (let j = 0; j < lines.length; j++) {\r\n                let line = lines[j].split('<p ')[1];\r\n                if (line === undefined) continue;\r\n                line = line.substring(line.indexOf('>') + 1, line.length);\r\n\r\n                if (i === 0) {\r\n                    rang = line.substring(0, line.indexOf('>')).split(' ');\r\n                    rangout = [];\r\n                    rang.forEach((a, k) => {\r\n                        rang[k] = rang[k].split('=');\r\n                        if (rang[k][0] === 'begin') {\r\n                            rangout[0] = this.convertToTime(rang[k][1].replaceAll('\"', ''));\r\n                        }\r\n                        else if (rang[k][0] === 'end') {\r\n                            rangout[1] = this.convertToTime(rang[k][1].replaceAll('\"', ''));\r\n                        }\r\n                    })\r\n                }\r\n\r\n                sub.ranges.push(rangout);\r\n                sub.meta.langs[lang].push(line.split('<br />'));\r\n            }\r\n        }\r\n\r\n        sub.subtitles = sub.meta.langs[flang];\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    }\r\n    /**\r\n     * Parse the given xml file text content, must be called once after starting the video!\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseXML(text, title, movie) {\r\n        let sections = text.split('<video>')[1].split('<video/>')[0].split('</title>'),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                text: text,\r\n                type: 'xml'\r\n            };\r\n        sections.pop();\r\n\r\n        for (let i = 0; i < sections.length; i++) {\r\n            const section = sections[i].split('<title>')[1];\r\n            rang0 = this.convertToTime(section.split('<start>')[1].split('</start>')[0].replace(';', '.'));\r\n            rang1 = this.convertToTime(section.split('<end>')[1].split('</end>')[0].replace(';', '.'));\r\n            rang = [rang0, rang1];\r\n            sub.ranges.push(rang);\r\n            subtitle = section.split('<text>')[1].split('</text>')[0].split('<br/>');\r\n            sub.subtitles.push(subtitle);\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    }\r\n    /**\r\n     * Parse the given webvtt file text content, must be called once after starting the video!\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseWEBVTT(text, title, movie) {\r\n        let sections = text.split('\\n'), openSection = false,\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                text: text,\r\n                type: 'webvtt'\r\n            };\r\n        // that's all it is\r\n        let subtitle = [];\r\n        for (let i = 0; i < sections.length; i++) {\r\n            const line = sections[i];\r\n\r\n            // ignoring comments\r\n            if (line.indexOf('NOTE ') !== -1 || line[0].indexOf('NOTE\\n') !== -1) continue;\r\n\r\n            if (openSection && (line.length !== 1 || line.length !== 0))\r\n                subtitle.push(line);\r\n\r\n            if (line.indexOf('-->') !== -1) {\r\n                let rang = this.getSeconds(line);\r\n                sub.ranges.push(rang);\r\n                openSection = true;\r\n            }\r\n            else if ((line.length === 1 || line.length === 0) && openSection === true) {\r\n                openSection = false;\r\n                sub.subtitles.push(subtitle);\r\n                subtitle = [];\r\n            }\r\n\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    }\r\n    /**\r\n     * Parse the given .sbv file format and subtract all subtitles and their durations.\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseSBV(text, title, movie) {\r\n        let data = text.split('\\n'), off = false, two = false, k = -1,\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                text: text,\r\n                type: 'sbv'\r\n            };\r\n\r\n        if (data[0].length === 1 || data[0].length === 0) off = true;\r\n        for (let i = 0; i < data.length; i++) {\r\n            let line = data[i];\r\n\r\n            if (two === true && line.length !== 1 && line.length !== 0)\r\n                sub.subtitles[k].push(line);\r\n\r\n            if (off === true) {\r\n                sub.ranges.push(this.getSeconds(line));\r\n                off = false;\r\n                two = true;\r\n                k++;\r\n                sub.subtitles[k] = [];\r\n            }\r\n            if (line.length === 1 || line.length === 0) {\r\n                off = true;\r\n                two = false;\r\n            }\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    }\r\n    /**\r\n     * Parse the given .ssa file format and subtract all subtitles and their durations.\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseSSA(text, title, movie) {\r\n        let data = text.split('\\n'), syntax = null, section = null,\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'ssa'\r\n            };\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n            const line = data[i];\r\n            let section;\r\n\r\n            if (line[0] === '[')\r\n                // that means we enter a section \r\n                // and now we will check what does the section contains\r\n                section = line.substring(1, line.indexOf(']') - 1).toLowerCase();\r\n            else {\r\n                if (section === 'events') {\r\n                    let pieces = line.split(':');\r\n                    if (pieces.length > 2) {\r\n                        for (let j = 2; j < pieces.length; j++) {\r\n                            pieces[1] += ':' + pieces[j];\r\n                        }\r\n\r\n                        pieces.splice(2, pieces.length);\r\n                    }\r\n                    let lineSubject = pieces[0].toLowerCase();\r\n                    let lineBody = pieces[1];\r\n\r\n                    // line may be a format explain or a dialog\r\n                    if (lineSubject === 'format') {\r\n                        syntax = lineBody.toLowerCase().split(',');\r\n                    }\r\n                    else if (lineSubject === 'dialogue') {\r\n                        // because for dialogs line contains more information then just the text\r\n                        // there is the speaker and some other stuffs and that's ordered according \r\n                        // to the format line we found above\r\n\r\n                        let lineBodySections = lineBody.split(',');\r\n\r\n                        // getting the subtitle\r\n                        k = syntax.findIndex(a => a.trim() === 'text');\r\n                        let string = lineBodySections[k];\r\n\r\n                        // getting the time rang\r\n                        i0 = syntax.findIndex(a => a.toLowerCase().trim() === 'start');\r\n                        i1 = syntax.findIndex(a => a.toLowerCase().trim() === 'end');\r\n\r\n                        t1 = this.convertToTime(lineBodySections[i0]);\r\n                        t2 = this.convertToTime(lineBodySections[i1]);\r\n\r\n                        sub.ranges.push([t1, t2]);\r\n                        sub.subtitles.push([string]);\r\n                    }\r\n                }\r\n                else if (section === 'script info') {\r\n                    if (line[0] === ';') continue; // stands for comments lines\r\n                    pieces = line.split(':');\r\n                    lineSubject = pieces[0];\r\n                    sub.meta[lineSubject] = pieces[1];\r\n                }\r\n            }\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    }\r\n    /**\r\n     * Parse the given .rt file format and subtract all subtitles and their durations.\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseRT(text, title, movie) {\r\n        let data = text.split('<br/>'), section = [],\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'rt'\r\n            };\r\n\r\n        // taking rid of the useless part\r\n        data.shift();\r\n        // fixing some part\r\n        data[data.length - 1] = data[data.length - 1].split('</font>')[0];\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n            section = data[i].split('<clear/>');\r\n            rang = section[0].split('<time ')[1].split('/>')[0].split(' ');\r\n            rangout = [];\r\n            for (let j = 0; j < rang.length; j++) {\r\n                const element = rang[j].split('=');\r\n                prop = element[0].toLowerCase();\r\n                config = element[1].replaceAll('\"', '');\r\n                if (prop === 'begin') {\r\n                    rangout[0] = parseFloat(config);\r\n                }\r\n                else if (prop === 'end') {\r\n                    rangout[1] = parseFloat(config);\r\n                }\r\n            }\r\n\r\n            // fixing the older rang if missing end property\r\n            if (sub.ranges[sub.ranges.length - 1] !== undefined && sub.ranges[sub.ranges.length - 1].length === 1) {\r\n                sub.ranges[sub.ranges.length - 1].push(rangout[0]);\r\n            }\r\n            sub.ranges.push(rangout);\r\n            sub.subtitles.push(section[1].split('<br>'));\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    }\r\n    /**\r\n     * Parse the given .itt file format and subtract all subtitles and their durations.\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseITT(text, title, movie) {\r\n        let data = text.split('<body>')[1].split('</body>')[0].split('<p '), pos = 0, timeRang = null,\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'itt'\r\n            }, raw = null, betterText = null;\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (data[i][0] !== 'b') continue; // empty unrecognised line are ignored\r\n\r\n            const sect = data[i].split('>');\r\n\r\n            // getting the time rang that exist inside the p element in the format `start=\"hh:mm:ss.xx\" dur=\"hh:mm:ss.xx\"`\r\n            raw = sect[0].split('\"');\r\n            // now after we split we have the the array with this content ['start','hh:mm:ss.xx','dur','hh:mm:ss.xx']\r\n            // we now convert each indivual cell time\r\n            timeRang = [this.convertToTime(raw[1]), this.convertToTime(raw[3])];\r\n            // because the itt file time definition uses the format `start : dur` \r\n            // instead or `start : end` we need to do the incrimentations so our system could work well\r\n            timeRang[1] += timeRang[0];\r\n            // after we subtract the data from the first array cell it's good to take rid of it\r\n            // so it no more bother us\r\n            sect.shift();\r\n\r\n            let subtitle = '';\r\n            // this step needs to loop through the string to take rid of the span element inside\r\n            // of it and only absord the subtitle pure text\r\n            for (let j = 0; j < sect.length; j++) {\r\n                const string = sect[j];\r\n                // why <br instead of the whole string <br> \r\n                // simply because we take rid of the > when we split the string using it\r\n                betterText = string.replaceAll('<br', '\\n');\r\n\r\n                for (let k = 0; k < betterText.length; k++) {\r\n                    if (betterText[k] + betterText[k + 1] + betterText[k + 2] + betterText[k + 3] + betterText[k + 4] === '<span' || betterText[k] + betterText[k + 1] === '</') {\r\n                        break;\r\n                    }\r\n                    else {\r\n                        subtitle += betterText[k];\r\n                    }\r\n                }\r\n            }\r\n            subtitle = subtitle.split('\\n'); // we split to get the array\r\n            sub.ranges.push(timeRang);\r\n            sub.subtitles.push(subtitle);\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    }\r\n    /**\r\n     * Parse the given .usf file format and subtract all subtitles and their durations.\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseUSF(text, title, movie) {\r\n        let meta = text.split('<metadata>')[1].split('</metadata>')[0],\r\n            data = text.split('<subtitles>')[1].split('</subtitles>')[0].split('<subtitle '),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                ranges: [],\r\n                meta: {},\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'usf'\r\n            }, fline = '', sline = '', ino = false, splitter = [null, null];\r\n\r\n\r\n        // getting the meta data\r\n        if (meta.indexOf('<title>') !== -1) {\r\n            sub.meta.title = meta.split('<title>')[1].split('</title>')[0];\r\n        }\r\n        if (meta.indexOf('<date>') !== -1) {\r\n            sub.meta.date = meta.split('<date>')[1].split('</date>')[0];\r\n        }\r\n        if (meta.indexOf('<author>') !== -1) {\r\n            let authorData = meta.split('<author>')[1].split('</author>')[0];\r\n            if (authorData.indexOf('<name>') !== -1) {\r\n                sub.meta.authorName = authorData.split('<name>')[1].split('</name>')[0];\r\n            }\r\n            if (authorData.indexOf('<url>') !== -1) {\r\n                sub.meta.authorUrl = authorData.split('<url>')[1].split('</url>')[0];\r\n            }\r\n            if (authorData.indexOf('<email>') !== -1) {\r\n                sub.meta.authorEmail = authorData.split('<email>')[1].split('</email>')[0];\r\n            }\r\n        }\r\n        if (meta.indexOf('<language') !== -1) {\r\n            sub.meta.language = \"\";\r\n            t = meta.split('<language ')[1].split('</language>')[0];\r\n            sub.meta.language = t.substring(t.indexOf('>') + 1, t.length);\r\n        }\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (data[i][0] !== 's') continue; // empty recognised lines are ignored\r\n\r\n            const line = data[i];\r\n            const timeRang = data[i].split('>')[0].split('\"');\r\n            let begin = this.convertToTime(timeRang[1]);\r\n            let end = this.convertToTime(timeRang[3]);\r\n\r\n\r\n            // choosing the right splitter\r\n            if (line.indexOf('<text ') !== -1) {\r\n                splitter[0] = '<text ';\r\n                splitter[1] = '</text>';\r\n            }\r\n            else if (line.indexOf('<karaoke ') !== -1) {\r\n                splitter[0] = '<karaoke ';\r\n                splitter[1] = '</karaoke>';\r\n            }\r\n\r\n            // doing the subtraction\r\n            sline = line.split(splitter[0])[1].split(splitter[1])[0];\r\n            fline = '';\r\n            ino = false;\r\n            for (let k = sline.indexOf('>'); k < sline.length; k++) {\r\n                const element = sline[k];\r\n\r\n                if (sline[k] === '<' && sline[k + 1] !== ' ') {\r\n                    ino = false;\r\n                }\r\n\r\n                if (ino) {\r\n                    fline += element;\r\n                }\r\n\r\n\r\n                if (element === '>') {\r\n                    ino = true;\r\n                }\r\n\r\n            }\r\n\r\n            // make sure there is no other subtitle that collides with this one.\r\n            let alr = sub.ranges.findIndex(a => begin >= a[0] && begin <= a[1]);\r\n            if (alr !== -1) {\r\n                sub.subtitles[alr] = sub.subtitles[alr].concat(fline.split('\\n'));\r\n            }\r\n            else {\r\n                sub.subtitles.push(fline.split('\\n'));\r\n                sub.ranges.push([begin, end]);\r\n            }\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    }\r\n    /**\r\n     * Parse the given .subti file format and subtract all subtitles and their durations.\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseSUBTI(text, title, movie) {\r\n        let data = text.split('=='),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'subti'\r\n            };\r\n\r\n        // now data contains at the first section the meta data\r\n        // so let's subtract it\r\n        let meta = data[0].split('\\n');\r\n        meta.pop();\r\n        for (let j = 0; j < meta.length; j++) {\r\n            const element = meta[j].split('=');\r\n            sub.meta[element[0]] = element[1];\r\n        }\r\n\r\n        sub.meta.names = [];\r\n        // now moving the actual subtitles\r\n        for (let i = 1; i < data.length; i++) {\r\n            const section = data[i].split('\\n');\r\n            // doing this will add two empty cells at the begin and\r\n            // the end of the section array\r\n            // we need to delete them\r\n            // getting the time\r\n            // the first empty cell well it's not totally empty some times ou find the talker name in it\r\n            // so let's save any way\r\n            sub.meta.names.push(section[0]);\r\n            section.shift();// this to delete the empty cell\r\n            sub.ranges.push(this.getSeconds(section[0]));\r\n            section.shift();// to delete the cell containing the time rang\r\n            if (section[section.length - 1] === '') section.pop();  // to delete the last empty cell\r\n            // now the subtitle\r\n            sub.subtitles.push(section);\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    }\r\n    /**\r\n     * Parse the given .lrc file format and subtract all lyric and their durations.\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseLRC(text, title, movie) {\r\n        let data = text.split('\\n'),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'lrc'\r\n            };\r\n        // subtracting meta\r\n\r\n\r\n        // subtracting main\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (data[i].length === 1 || data[i].length === 0) continue;\r\n            const line = data[i].split('[')[1].split(']');\r\n            let descrip = line[0];\r\n            let body = line[1];\r\n\r\n            if (nums.indexOf(descrip[0]) === -1) {\r\n                // basically this is means this is a meta data about the file\r\n                subj = descrip.substring(0, descrip.indexOf(':'));\r\n                elm = descrip.substring(descrip.indexOf(':') + 1, descrip.length);\r\n                if (subj === 'au') subj = 'author';\r\n                if (subj === 'ar') subj = 'artist';\r\n                if (subj === 'al') subj = 'album';\r\n                if (subj === 'ti') subj = 'title';\r\n                sub.meta[subj] = elm;\r\n            } else {\r\n                // means this is a lyric line\r\n                rang = this.convertToTime(descrip);\r\n                k = sub.ranges.push([rang]);\r\n                sub.subtitles.push([body]);\r\n\r\n                if (sub.ranges[k - 2] !== undefined) {\r\n                    sub.ranges[k - 2].push(rang);\r\n                }\r\n            }\r\n        }\r\n        sub.ranges[sub.ranges.length - 1].push(Infinity);\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    }\r\n    /**\r\n     * Convert a given time in seconds to a proper format to be used in a subtitle file in this way `hh:mm:ss.xx` seperated\r\n     * by the given separator.\r\n     * @param {number} time \r\n     * @param {string} separator default is `:`\r\n     * @param {string} fractionSymbol default is `.`\r\n     * @returns {string}\r\n     */\r\n    convertToText(time, separator, fractionSymbol) {\r\n        separator = separator || \":\";\r\n        fractionSymbol = fractionSymbol || \".\";\r\n        let hours = Math.floor(time / 3600);\r\n        time = time - (hours * 3600);\r\n        let minutes = Math.floor(time / 60);\r\n        time = time - (minutes * 60);\r\n        let seconds = time.toFixed(2);\r\n        seconds = seconds.replace('.', fractionSymbol);\r\n\r\n        return hours + separator + minutes + separator + seconds;\r\n    }\r\n    /**\r\n     * Convert the string in time notation `hh:mm:ss` or `hh:mm:ss.xx` to real number represent time \r\n     * in seconds. used internally by the library!\r\n     * @param {string} time \r\n     * @returns {number}\r\n     */\r\n    convertToTime(time) {\r\n        let dur = 0, begin, end, hours, minutes, seconds;\r\n        let org = time.split(':');\r\n\r\n\r\n        // now parse the hours minutes and seconds\r\n        if (org.length === 3) {\r\n\r\n            // something should be done after using parseFloat function:\r\n            // we should change the `,` to `.` so the function does right parsing\r\n            // this is only in srt file\r\n            org[2] = org[2].replace(',', '.');\r\n\r\n\r\n            hours = parseFloat(org[0]);\r\n            minutes = parseFloat(org[1]);\r\n            seconds = parseFloat(org[2]);\r\n        }\r\n        else {\r\n            org[1] = org[1].replace(',', '.');\r\n\r\n\r\n            // for mm:ss.xx representation\r\n            hours = 0;\r\n            minutes = parseFloat(org[0]);\r\n            seconds = parseFloat(org[1]);\r\n        }\r\n\r\n        // then we convert all to seconds\r\n        dur += (hours * 3600) + (minutes * 60) + seconds;\r\n\r\n        return dur\r\n    }\r\n    /**\r\n     * Used internally by the class to parse a rang representation string into seconds count,\r\n     * for `srt` , `subti` , `sbv` and `webvtt` file formats.\r\n     * @param {string} repRang stands for representation rang\r\n     * @returns {Array}\r\n     */\r\n    getSeconds(repRang) {\r\n        let rang = [0, 0];\r\n        // first we seperate the rang, usually it's the form beginTime-->endTime in srt and webvtt\r\n        // files and beginTime,endTime in sbv files and beginTime=>endTime in subti files\r\n        // so we need to check the existance of the arrow, if not then we seperate with `,`\r\n        repRang = repRang.indexOf('=>') !== -1 ? repRang.split('=>') : repRang.indexOf('-->') === -1 ? repRang.split(',') : repRang.split('-->');\r\n\r\n        // using a local function we subtract time(convert it)\r\n        rang[0] = this.convertToTime(repRang[0]);\r\n        rang[1] = this.convertToTime(repRang[1]);\r\n\r\n        return rang;\r\n    }\r\n    /**\r\n     * Must be called as the video time updated or the loop updated, to render or display the subtitles.\r\n     */\r\n    update() {\r\n        if (this.mode === null)\r\n            return console.warn('Must set up the parser rendering mode first!\\`Subtity.setUp2D or Subtity.setUpContainer\\`');\r\n\r\n        if (this.ranges.length === 0 || this.subtitles.length === 0 || this.activated === false) return;\r\n\r\n        let current = this.video.currentTime * this.speedFactor;\r\n        let mov = this.video.src;\r\n\r\n        for (let i = 0; i < this.ranges.length; i++) {\r\n            const rang = this.ranges[i];\r\n            const text = this.subtitles[i];\r\n            current -= this.offset;\r\n\r\n            if (current >= rang[0] && current <= rang[1]) {\r\n                this.current = i;\r\n\r\n                if (this.mode === 1) {\r\n                    this.container.innerText = this.subtitles[this.current];\r\n                }\r\n                else {\r\n                    // for rendering mode we should get the options\r\n                    let family = this.style.family || 'Arial';\r\n                    let style = this.style.style || 'normal';\r\n                    let variant = this.style.variant || 'normal';\r\n                    let base = this.style.base || 90;\r\n                    let left = this.style.left || 50;\r\n                    let size = this.style.size || 25;\r\n                    let align = this.style.align || 'center';\r\n                    let color = this.style.color || 'white';\r\n                    let bg = this.style.bg || 'rgba(0,0,0,0)';\r\n                    let direction = this.style.direction || 'ltr';\r\n                    let opacity = this.style.opacity || 1;\r\n                    let weight = this.style.weight || 'bold';\r\n                    let marginL = this.style.marginLeft;\r\n                    let marginT = this.style.marginTop;\r\n                    let outlineColor = this.style.outlineColor || 'black';\r\n                    let outlineSize = this.style.outlineSize || 1;\r\n                    let shadowColor = this.style.shadowColor || 'rgba(0,0,0,0)';\r\n                    let shadowX = this.style.shadowX || 0;\r\n                    let shadowY = this.style.shadowY || 0;\r\n                    let shadowBlur = this.style.shadowBlur || 0;\r\n                    let lineSpacing = this.style.lineSpacing || 0;\r\n                    let lineHeight = this.style.lineHeight;\r\n\r\n                    this.renderer.beginPath();\r\n                    let x = (this.renderer.canvas.width / 100) * left;\r\n                    let y = (this.renderer.canvas.height / 100) * base;\r\n\r\n                    this.renderer.fillStyle = color;\r\n                    this.renderer.textAlign = align;\r\n                    this.renderer.direction = direction;\r\n                    this.renderer.font = `${style} ${variant} ${weight} ${size}px ${family}`;\r\n                    this.renderer.shadowColor = shadowColor;\r\n                    this.renderer.shadowBlur = shadowBlur;\r\n                    this.renderer.shadowOffsetX = shadowX;\r\n                    this.renderer.shadowOffsetY = shadowY;\r\n                    this.renderer.globalAlpha = opacity;\r\n\r\n\r\n                    // we loop from end to begin to save the natural order of the subtitles\r\n                    // because we drawing from bottom to top to\r\n                    for (let j = text.length - 1; j > -1; j--) {\r\n                        const line = text[j];\r\n\r\n                        this.renderer.strokeStyle = outlineColor;\r\n                        this.renderer.lineWidth = outlineSize * 2;\r\n                        this.renderer.strokeText(line, x, y);\r\n                        this.renderer.lineWidth = 1;\r\n                        this.renderer.fillText(line, x, y);\r\n                        y -= (lineHeight + lineSpacing);\r\n                    }\r\n\r\n                    this.renderer.closePath();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Set up the parser to render the text to a 2D CanvasRendering context, passing the HTMLCanvasElement\r\n     * to render on, and optional options list of styles to be applied to the text while rendering.\r\n     * @param {HTMLCanvasElement} canvas the canvas element or it context\r\n     * @param {HTMLVideoElement} video \r\n     */\r\n    setUp2D(canvas, video) {\r\n\r\n        this.renderer = canvas instanceof CanvasRenderingContext2D ? canvas : canvas.getContext('2d');\r\n        this.mode = 2;\r\n        this.video = video;\r\n    }\r\n    /**\r\n     * Set up the parser to use an HTMLElement to display the subtitles, passing the HTMLElement!\r\n     * @param {HTMLElement} elm \r\n     * @param {HTMLVideoElement} video \r\n     */\r\n    setUpContainer(elm, video) {\r\n        this.container = elm;\r\n        this.mode = 1;\r\n        this.video = video;\r\n    }\r\n    /**\r\n     * Set the offset value, pass positive number to progress or negative to delay the subtitle displaying process.\r\n     * @param {number} offset \r\n     */\r\n    setOffset(offset) {\r\n        this.offset = typeof offset === 'number' && !isNaN(offset) ? offset : this.offset;\r\n    }\r\n    /**\r\n     * Change the subtitle rendering speed\r\n     * @param {number} speed \r\n     */\r\n    setSpeed(speed) {\r\n        this.speedFactor = typeof speed === 'number' && !isNaN(speed) ? speed : this.speedFactor;\r\n    }\r\n    /**\r\n     * Customize the subtitles style when displaying, this is only applied when rendering\r\n     * to a 2D context, not when using normal DOM element.\r\n     * @param {string} style \r\n     * @param {any} value \r\n     */\r\n    set(style, value) {\r\n\r\n        switch (style) {\r\n            case 'family':\r\n                this.style.family = value;\r\n                this.calcFontHeight();\r\n                break;\r\n            case 'color':\r\n                this.style.color = value;\r\n                break;\r\n            case 'weight':\r\n                this.style.weight = value;\r\n                break;\r\n            case 'style':\r\n                this.style.style = value;\r\n                break;\r\n            case 'variant':\r\n                this.style.variant = value;\r\n                break;\r\n            case 'size':\r\n                this.style.size = parseFloat(value);\r\n                this.calcFontHeight();\r\n                break;\r\n            case 'align':\r\n                this.style.align = value;\r\n                break;\r\n            case 'direction':\r\n                this.style.direction = value;\r\n                break;\r\n            case 'shawX':\r\n                this.style.shadowX = parseFloat(value);\r\n                break;\r\n            case 'shawY':\r\n                this.style.shadowY = parseFloat(value);\r\n                break;\r\n            case 'shawBlur':\r\n                this.style.shadowBlur = value;\r\n                break;\r\n            case 'shawColor':\r\n                this.style.shadowColor = value;\r\n                break;\r\n            case 'bg':\r\n                this.style.bg = value;\r\n                break;\r\n            case 'outlineColor':\r\n                this.style.outlineColor = value;\r\n                break;\r\n            case 'outlineSize':\r\n                this.style.outlineSize = parseFloat(value);\r\n                break;\r\n            case 'lineSpacing':\r\n                this.style.lineSpacing = parseFloat(value);\r\n                break;\r\n            case 'base':\r\n                this.style.base = parseFloat(value);\r\n                break;\r\n            case 'left':\r\n                this.style.left = parseFloat(value);\r\n                break;\r\n            case 'opacity':\r\n                this.style.opacity = isNaN(parseFloat(value)) ? 1 : parseFloat(value);\r\n\r\n        }\r\n    }\r\n    /**\r\n     * Used internally by the engine to calculate the font height currently under use\r\n     * @returns {number}\r\n     */\r\n    calcFontHeight() {\r\n        let fontSize = parseFloat(this.style.size);\r\n        let fontFamily = this.style.family;\r\n\r\n        let modal = 'gM';\r\n        let context = this.ctx;\r\n        context.canvas.width = context.canvas.width;\r\n\r\n        context.fillRect(0, 0, context.canvas.width, context.canvas.height);\r\n        context.textBaseline = 'top';\r\n\r\n        context.font = fontSize + 'px ' + fontFamily;\r\n        context.fillStyle = 'white';\r\n\r\n        context.fillText(modal, 0, 0);\r\n\r\n        let data = context.getImageData(0, 0, context.canvas.width, context.canvas.height).data;\r\n\r\n        let start = -1;\r\n        let end = -1;\r\n        for (let i = 0; i < context.canvas.height; i++) {\r\n\r\n            for (let j = 0; j < context.canvas.width; j++) {\r\n                let index = (i * context.canvas.width + j) * 4;\r\n\r\n                if (data[index] === 0) {\r\n                    if (j === context.canvas.width - 1 && start !== -1) {\r\n                        end = i;\r\n                        i = context.canvas.height;\r\n                        break\r\n                    }\r\n                    continue\r\n                }\r\n                else {\r\n                    if (start === -1) {\r\n                        start = i;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.style.lineHeight = end - start;\r\n    }\r\n    /**\r\n     * Loads the default style applied to the rendering process\r\n     */\r\n    loadDefaultStyle() {\r\n        this.style = {\r\n            family: 'Arial',\r\n            size: 19,\r\n            lineSpacing: 10,\r\n            color: 'rgb(255,255,255)',\r\n            align: 'center',\r\n            direction: 'ltr',\r\n            outlineColor: 'rgb(0,0,0)',\r\n            outlineSize: 1,\r\n            shadowColor: 'rgba(0,0,0,0)',\r\n            opacity: 1,\r\n            shadowBlur: 0,\r\n            shadowX: 0,\r\n            shadowY: 0,\r\n            base: 90,\r\n            left: 50,\r\n            weight: '',\r\n            style: 'normal',\r\n            variant: 'normal'\r\n        }\r\n    }\r\n    /**\r\n     * Toggle the activation of the subtitle\r\n     * @param {boolean} state the state to force applying `false` to disactivate or `true` to activate.\r\n     * @returns {boolean} the new activation state\r\n     */\r\n    toggleActivation(state) {\r\n        if (typeof state === 'boolean') {\r\n            this.activated = state;\r\n        }\r\n        else {\r\n            this.activated = !this.activated;\r\n        }\r\n        return this.activated;\r\n    }\r\n    /**\r\n     * Remove a subtitle from the list\r\n     * @param {string} title \r\n     * @returns {object} the removed subtitle or false if it was not found\r\n     */\r\n    remove(title) {\r\n        let i = this.subs.findIndex(a => a.title === title);\r\n\r\n        if (i !== -1) {\r\n            if (this.subs[i].used === true) {\r\n                this.reset();\r\n            }\r\n            return this.subs.splice(i, 1);\r\n        }\r\n        return false\r\n    }\r\n    /**\r\n     * Add a new subtitle to the list\r\n     * @param {string} title the subtitle special title to use it later\r\n     * @param {string} text the subtitle file text content\r\n     * @param {string} ext the extension of the subtitle\r\n     * @param {string} movie the name of the movie this subtitle going to be used with\r\n     */\r\n    add(title, text, ext, movie) {\r\n        if (typeof ext !== 'string' || typeof text !== 'string' || title === '') return;\r\n\r\n        let res = this.check(title);\r\n        if (res === false) {\r\n            return;\r\n        }\r\n\r\n        ext = ext.toLowerCase();\r\n        if (ext === '.srt' || ext === 'srt') {\r\n            this.parseSRT(text, title, movie);\r\n        }\r\n        else if (ext === '.sbv' || ext === 'sbv') {\r\n            this.parseSBV(text, title, movie);\r\n        }\r\n        else if (ext === '.itt' || ext === 'itt') {\r\n            this.parseITT(text, title, movie);\r\n        }\r\n        else if (ext === '.webvtt' || ext === 'webvtt') {\r\n            this.parseWEBVTT(text, title, movie);\r\n        }\r\n        else if (ext === '.ssa' || ext === 'ssa') {\r\n            this.parseSSA(text, title, movie);\r\n        }\r\n        else if (ext === '.usf' || ext === 'usf') {\r\n            this.parseUSF(text, title, movie);\r\n        }\r\n        else if (ext === '.lrc' || ext === 'lrc') {\r\n            this.parseLRC(text, title, movie);\r\n        }\r\n        else if (ext === '.subti' || ext === 'subti') {\r\n            this.parseSUBTI(text, title, movie);\r\n        }\r\n        else if (ext === '.rt' || ext === 'rt') {\r\n            this.parseRT(text, title, movie);\r\n        }\r\n        else if (ext === '.dfxp' || ext === 'dfxp' || ext === 'ttml' || ext === '.ttml') {\r\n            this.parseXMLBased(text, title, movie);\r\n        }\r\n        else if (ext === '.xml' || ext === 'xml') {\r\n            this.parseXML(text, title, movie);\r\n        }\r\n    }\r\n    /**\r\n     * Export the current system stored subtitles into a file text in certain type\r\n     * @param {string} fileFormat \r\n     * @returns {string} the text content or `false` if cannot export to the given type/fileFormat\r\n     */\r\n    export(fileFormat) {\r\n        if (typeof fileFormat !== 'string') return;\r\n\r\n        fileFormat = fileFormat.toLowerCase();\r\n        let text = false;\r\n\r\n        if (fileFormat === '.srt' || fileFormat === 'srt') {\r\n            text = this.exportToSRT();\r\n        }\r\n        else if (fileFormat === '.sbv' || fileFormat === 'sbv') {\r\n            // to be done\r\n        }\r\n        else if (fileFormat === '.itt' || fileFormat === 'itt') {\r\n            // ti be done\r\n        }\r\n        else if (fileFormat === '.webvtt' || fileFormat === 'webvtt') {\r\n            text = this.exportToWEBVTT();\r\n        }\r\n        else if (fileFormat === '.ssa' || fileFormat === 'ssa') {\r\n            text = this.exportToSSA();\r\n        }\r\n        else if (fileFormat === '.usf' || fileFormat === 'usf') {\r\n            // to be done\r\n        }\r\n        else if (fileFormat === '.lrc' || fileFormat === 'lrc') {\r\n            text = this.exportToLRC();\r\n        }\r\n        else if (fileFormat === '.subti' || fileFormat === 'subti') {\r\n            text = this.exportToSUBTI();\r\n        }\r\n\r\n        return text\r\n    }\r\n    /**\r\n     * Check whether a title is under use or not, then warn to console if it's is\r\n     * @param {string} title\r\n     * @returns {boolean}\r\n     */\r\n    check(title) {\r\n        let index = this.subs.findIndex(a => a.title === title);\r\n        if (index !== -1) {\r\n            console.warn('The given title( ' + title + ') is already under use, please use a new one');\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Export the current system content of subtitles and ranges to an .srt file formats text\r\n     * @returns {string}\r\n     */\r\n    exportToSRT() {\r\n        let text = '';\r\n        for (let i = 0; i < this.subtitles.length; i++) {\r\n            const sub = this.subtitles[i];\r\n            const rang = this.ranges[i];\r\n            let sect = (i + 1) + '\\n';\r\n            sect += this.convertToText(rang[0], ':', ',') + ' --> ' + this.convertToText(rang[1], ':', ',') + '\\n';\r\n\r\n            sect += sub.join('\\n');\r\n\r\n            text += sect + '\\n';\r\n        }\r\n\r\n        return text;\r\n    }\r\n    /**\r\n     * Export the current system content of subtitles and ranges to an .webvtt file formats text\r\n     * @returns {string}\r\n     */\r\n    exportToWEBVTT() {\r\n        let text = 'WEBVTT\\n';\r\n\r\n        for (let i = 0; i < this.subtitles.length; i++) {\r\n            const sub = this.subtitles[i];\r\n            const rang = this.ranges[i];\r\n            let sect = (i + 1) + '\\n';\r\n            sect += this.convertToText(rang[0]) + ' --> ' + this.convertToText(rang[1]) + '\\n';\r\n\r\n            sect += sub.join('\\n');\r\n\r\n            text += sect + '\\n';\r\n        }\r\n\r\n        return text;\r\n    }\r\n    /**\r\n     * Export the current system content of subtitles and ranges to an .subti file formats text\r\n     * @returns {string}\r\n     */\r\n    exportToSUBTI() {\r\n        let text = '';\r\n\r\n        // inserting the meta data first\r\n        for (const key in this.meta) {\r\n            if (this.meta.hasOwnProperty(key)) {\r\n                const element = this.meta[key];\r\n                s = key + ' = ' + element + '\\n';\r\n                text += s;\r\n            }\r\n        }\r\n        text += '==';\r\n        let names = this.meta.names !== undefined ? this.meta.names : [];\r\n\r\n        // now inserting the subtitles\r\n        for (let i = 0; i < this.subtitles.length; i++) {\r\n            const subtitle = this.subtitles[i];\r\n            const rang = this.ranges[i];\r\n            const name = names[i] !== undefined ? names[i] : '';\r\n\r\n            let sect = name + '\\n';\r\n            sect += this.convertToText(rang[0]) + '=>' + this.convertToText(rang[1]) + '\\n';\r\n\r\n            sect += subtitle.join('\\n');\r\n\r\n            text += sect + '\\n==';\r\n        }\r\n\r\n        return text\r\n    }\r\n    /**\r\n     * Export the current system content of subtitles and ranges to an .lrc file formats text\r\n     * @returns {string}\r\n     */\r\n    exportToLRC() {\r\n        let text = '';\r\n        // first packaging the meta data\r\n        for (const key in this.meta) {\r\n            if (this.meta.hasOwnProperty(key)) {\r\n                const value = this.meta[key];\r\n                name = key === 'artist' ? 'ar' : key === 'album' ? 'al' : key === 'title' ? 'ti' : key === 'author' ? 'au' : key;\r\n                text += '[' + name + ':' + value + ']\\n';\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this.subtitles.length; i++) {\r\n            const sub = this.subtitles[i][0];\r\n            const rang = this.convertToText(this.ranges[i][0]);\r\n            text += '[' + rang + ']' + sub + '\\n';\r\n        }\r\n\r\n        return text;\r\n    }\r\n    /**\r\n     * Export the current system content of subtitles and ranges to an .ssa file formats text\r\n     * @returns {string}\r\n     */\r\n    exportToSSA() {\r\n        text = '[Script Info]\\n';\r\n        // packaging the meta data\r\n        for (const key in this.meta) {\r\n            if (this.meta.hasOwnProperty(key)) {\r\n                const element = this.meta[key];\r\n                text += key + ': ' + element + '\\n';\r\n            }\r\n        }\r\n        text += '\\n';\r\n\r\n        // now the subtitle\r\n        text += '[Events]\\n';\r\n        // declaring the format\r\n        text += 'Format: Start, End, Name, Text\\n';\r\n        let names = this.meta.names !== undefined ? this.meta.names : [];\r\n\r\n        for (let i = 0; i < this.subtitles.length; i++) {\r\n            const sub = this.subtitles[i];\r\n            const rang1 = this.convertToText(this.ranges[i][0]);\r\n            const rang2 = this.convertToText(this.ranges[i][1]);\r\n            const name = names[i] !== undefined ? names[i] : 'Unknown';\r\n\r\n            text += 'Dialogue: ' + rang1 + ',' + rang2 + ',' + name + ',' + sub + '\\n';\r\n        }\r\n\r\n        return text\r\n    }\r\n    /**\r\n     * Change the current subtitle language if subtitle file provided with multi languages, this is only supported with certain\r\n     * file formats like `.dfxp`.\r\n     * @param {string} lang the first two letter of the language for example for `english` you pass `en` and so on... \r\n     */\r\n    switchToLang(lang) {\r\n        if (this.meta.langs !== undefined) {\r\n            if (this.meta.langs.hasOwnProperty(lang)) {\r\n                this.subtitles = this.meta.langs[lang];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default Subtity;"],"names":["nums","subs","title","text","subtitles","ranges","current","subtitlesCounts","offset","style","family","size","lineSpacing","variant","color","align","direction","outlineColor","outlineSize","shadowColor","opacity","shadowBlur","shadowX","shadowY","base","left","weight","renderer","container","meta","mode","video","ctx","document","createElement","getContext","activated","currentFileType","speedFactor","constructor","reset","this","use","i","findIndex","a","j","used","count","type","calcFontHeight","parseSRT","movie","sections","split","sub","isNam","subtitle","length","line","push","indexOf","getSeconds","parseXMLBased","langs","lang","rang","flang","rangout","element","undefined","keyword","substring","forEach","replaceAll","lines","k","convertToTime","parseXML","pop","section","rang0","replace","rang1","parseWEBVTT","openSection","parseSBV","data","off","two","parseSSA","syntax","toLowerCase","pieces","splice","lineSubject","lineBody","lineBodySections","trim","string","i0","i1","t1","t2","parseRT","shift","prop","config","parseFloat","parseITT","timeRang","raw","betterText","sect","parseUSF","fline","sline","ino","splitter","date","authorData","authorName","authorUrl","authorEmail","language","t","begin","end","alr","concat","parseSUBTI","names","parseLRC","descrip","body","subj","elm","Infinity","convertToText","time","separator","fractionSymbol","hours","Math","floor","minutes","seconds","toFixed","dur","org","repRang","update","console","warn","currentTime","src","innerText","bg","marginLeft","marginTop","lineHeight","beginPath","x","canvas","width","y","height","fillStyle","textAlign","font","shadowOffsetX","shadowOffsetY","globalAlpha","strokeStyle","lineWidth","strokeText","fillText","closePath","setUp2D","CanvasRenderingContext2D","setUpContainer","setOffset","isNaN","setSpeed","speed","set","value","fontSize","fontFamily","context","fillRect","textBaseline","getImageData","start","loadDefaultStyle","toggleActivation","state","remove","add","ext","check","fileFormat","exportToSRT","exportToWEBVTT","exportToSSA","exportToLRC","exportToSUBTI","join","key","hasOwnProperty","s","name","rang2","switchToLang"],"mappings":"wOAoBA,IAAIA,EAAO,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,YA6BzD,MAMIC,KAAO,GAMPC,MAAQ,GAORC,KAAO,GAMPC,UAAY,GAMZC,OAAS,GAOTC,QAAU,EAMVC,gBAAkB,KAOlBC,OAAS,EAMTC,MAAQ,CACJC,OAAQ,QACRC,KAAM,GACNF,MAAO,SACPG,YAAa,EACbC,QAAS,SACTC,MAAO,mBACPC,MAAO,SACPC,UAAW,MACXC,aAAc,aACdC,YAAa,EACbC,YAAa,gBACbC,QAAS,EACTC,WAAY,EACZC,QAAS,EACTC,QAAS,EACTC,KAAM,GACNC,KAAM,GACNC,OAAQ,IAOZC,SAAW,KAMXC,UAAY,KAMZC,KAAO,CAAA,EAUPC,KAAO,KAMPC,MAAQ,KAMRC,IAAMC,SAASC,cAAc,UAAUC,WAAW,MAMlDC,WAAY,EAMZC,gBAAkB,KAMlBC,YAAc,EAEd,WAAAC,GAEC,CAKD,KAAAC,GACIC,KAAKnC,QAAU,EACfmC,KAAKH,YAAc,EACnBG,KAAKjC,OAAS,EACdiC,KAAKhC,MAAQ,CACTC,OAAQ,QACRC,KAAM,GACNF,MAAO,SACPI,QAAS,SACTD,YAAa,GACbE,MAAO,mBACPC,MAAO,SACPC,UAAW,MACXC,aAAc,aACdC,YAAa,EACbC,YAAa,gBACbE,WAAY,EACZD,QAAS,EACTE,QAAS,EACTC,QAAS,EACTC,KAAM,GACNC,KAAM,GACNC,OAAQ,IAEZe,KAAKrC,UAAY,GACjBqC,KAAKpC,OAAS,GACdoC,KAAKL,WAAY,EACjBK,KAAKlC,gBAAkB,EACvBkC,KAAKZ,KAAO,GACZY,KAAKvC,MAAQ,GACbuC,KAAKJ,gBAAkB,IAC1B,CAKD,GAAAK,CAAIxC,GACA,IAAIyC,EAAIF,KAAKxC,KAAK2C,WAAUC,GAAKA,EAAE3C,QAAUA,IAC7C,IAAU,IAANyC,EAAJ,CAEA,GAAmB,KAAfF,KAAKvC,MAAc,CACnB,IAAI4C,EAAIL,KAAKxC,KAAK2C,WAAUC,GAAKA,EAAE3C,QAAUuC,KAAKvC,QAClDuC,KAAKxC,KAAK6C,GAAGC,MAAO,CACvB,CAEDN,KAAKnC,QAAU,EAEfmC,KAAKD,QACLC,KAAKxC,KAAK0C,GAAGI,MAAO,EACpBN,KAAKvC,MAAQuC,KAAKxC,KAAK0C,GAAGzC,MAC1BuC,KAAKpC,OAASoC,KAAKxC,KAAK0C,GAAGtC,OAC3BoC,KAAKrC,UAAYqC,KAAKxC,KAAK0C,GAAGvC,UAC9BqC,KAAKtC,KAAOsC,KAAKxC,KAAK0C,GAAGxC,KACzBsC,KAAKlC,gBAAkBkC,KAAKxC,KAAK0C,GAAGK,MACpCP,KAAKL,WAAY,EACjBK,KAAKZ,KAAOY,KAAKxC,KAAK0C,GAAGd,KACzBY,KAAKJ,gBAAkBI,KAAKxC,KAAK0C,GAAGM,KAEpCR,KAAKS,gBApBgB,CAqBxB,CAOD,QAAAC,CAAShD,EAAMD,EAAOkD,GAClB,IAAIC,EAAWlD,EAAKmD,MAAM,MACtBC,EAAM,CACFH,MAAOA,EACPlD,MAAOA,EACPG,OAAQ,GACRwB,KAAM,CAAE,EACRzB,UAAW,GACXD,KAAMA,EACN6C,MAAO,EACPC,KAAM,OAGVO,GAAQ,EACRC,EAAW,GACf,IAAK,IAAId,EAAI,EAAGA,EAAIU,EAASK,OAAQf,IAAK,CACtC,MAAMgB,EAAON,EAASV,GAEF,GAAfgB,EAAKD,QAA+B,IAAhBC,EAAKD,QAAqC,IAApBD,EAASC,SACpDF,GAAQ,EACRD,EAAInD,UAAUwD,KAAKH,GACnBA,EAAW,KAGa,IAAxBE,EAAKE,QAAQ,WACbN,EAAIlD,OAAOuD,KAAKnB,KAAKqB,WAAWH,IAChCH,GAAQ,IAEO,IAAVA,GAAkC,IAAhBG,EAAKD,QAC5BD,EAASG,KAAKD,EAErB,CAEDJ,EAAIP,MAAQO,EAAInD,UAAUsD,OAC1BjB,KAAKxC,KAAK2D,KAAKL,EAClB,CAQD,aAAAQ,CAAc5D,EAAMD,EAAOkD,GACvB,IAAIC,EAAWlD,EAAKmD,MAAM,UAAU,GAAGA,MAAM,WAAW,GAAGA,MAAM,UAC7DC,EAAM,CACFH,MAAOA,EACPlD,MAAOA,EACP2B,KAAM,CACFmC,MAAO,CAAE,GAEb3D,OAAQ,GACRD,UAAW,GACXD,KAAMA,EACN8C,KAAM,QACPgB,EAAO,KACVC,EAAO,KACPC,EAAQ,KACRC,EAAU,KAEd,IAAK,IAAIzB,EAAI,EAAGA,EAAIU,EAASK,OAAQf,IAAK,CACtC,MAAM0B,EAAUhB,EAASV,GAAGW,MAAM,SAAS,GAC3C,QAAgBgB,IAAZD,EAAuB,SAE3B,IAAIE,EAAUF,EAAQG,UAAU,EAAGH,EAAQR,QAAQ,MAAMP,MAAM,KAE/DiB,EAAQE,SAAQ,CAAC5B,EAAGF,KAChB4B,EAAQ5B,GAAK4B,EAAQ5B,GAAGW,MAAM,KACR,aAAlBiB,EAAQ5B,GAAG,KACXsB,EAAOM,EAAQ5B,GAAG,GAAG+B,WAAW,IAAK,IACvB,OAAVP,IAAgBA,EAAQF,GAC5BV,EAAI1B,KAAKmC,MAAMC,GAAQ,OAI/B,IAAIU,EAAQN,EAAQf,MAAM,QACb,OAATW,IACAA,EAAO,KACO,OAAVE,IAAgBA,EAAQF,IAEhC,IAAK,IAAInB,EAAI,EAAGA,EAAI6B,EAAMjB,OAAQZ,IAAK,CACnC,IAAIa,EAAOgB,EAAM7B,GAAGQ,MAAM,OAAO,QACpBgB,IAATX,IACJA,EAAOA,EAAKa,UAAUb,EAAKE,QAAQ,KAAO,EAAGF,EAAKD,QAExC,IAANf,IACAuB,EAAOP,EAAKa,UAAU,EAAGb,EAAKE,QAAQ,MAAMP,MAAM,KAClDc,EAAU,GACVF,EAAKO,SAAQ,CAAC5B,EAAG+B,KACbV,EAAKU,GAAKV,EAAKU,GAAGtB,MAAM,KACL,UAAfY,EAAKU,GAAG,GACRR,EAAQ,GAAK3B,KAAKoC,cAAcX,EAAKU,GAAG,GAAGF,WAAW,IAAK,KAEvC,QAAfR,EAAKU,GAAG,KACbR,EAAQ,GAAK3B,KAAKoC,cAAcX,EAAKU,GAAG,GAAGF,WAAW,IAAK,UAKvEnB,EAAIlD,OAAOuD,KAAKQ,GAChBb,EAAI1B,KAAKmC,MAAMC,GAAML,KAAKD,EAAKL,MAAM,WACxC,CACJ,CAEDC,EAAInD,UAAYmD,EAAI1B,KAAKmC,MAAMG,GAC/BZ,EAAIP,MAAQO,EAAInD,UAAUsD,OAC1BjB,KAAKxC,KAAK2D,KAAKL,EAClB,CAOD,QAAAuB,CAAS3E,EAAMD,EAAOkD,GAClB,IAAIC,EAAWlD,EAAKmD,MAAM,WAAW,GAAGA,MAAM,YAAY,GAAGA,MAAM,YAC/DC,EAAM,CACFH,MAAOA,EACPlD,MAAOA,EACP2B,KAAM,CAAE,EACRxB,OAAQ,GACRD,UAAW,GACXD,KAAMA,EACN8C,KAAM,OAEdI,EAAS0B,MAET,IAAK,IAAIpC,EAAI,EAAGA,EAAIU,EAASK,OAAQf,IAAK,CACtC,MAAMqC,EAAU3B,EAASV,GAAGW,MAAM,WAAW,GAC7C2B,MAAQxC,KAAKoC,cAAcG,EAAQ1B,MAAM,WAAW,GAAGA,MAAM,YAAY,GAAG4B,QAAQ,IAAK,MACzFC,MAAQ1C,KAAKoC,cAAcG,EAAQ1B,MAAM,SAAS,GAAGA,MAAM,UAAU,GAAG4B,QAAQ,IAAK,MACrFhB,KAAO,CAACe,MAAOE,OACf5B,EAAIlD,OAAOuD,KAAKM,MAChBT,SAAWuB,EAAQ1B,MAAM,UAAU,GAAGA,MAAM,WAAW,GAAGA,MAAM,SAChEC,EAAInD,UAAUwD,KAAKH,SACtB,CAEDF,EAAIP,MAAQO,EAAInD,UAAUsD,OAC1BjB,KAAKxC,KAAK2D,KAAKL,EAClB,CAOD,WAAA6B,CAAYjF,EAAMD,EAAOkD,GACrB,IAAIC,EAAWlD,EAAKmD,MAAM,MAAO+B,GAAc,EAC3C9B,EAAM,CACFH,MAAOA,EACPlD,MAAOA,EACP2B,KAAM,CAAE,EACRxB,OAAQ,GACRD,UAAW,GACXD,KAAMA,EACN8C,KAAM,UAGVQ,EAAW,GACf,IAAK,IAAId,EAAI,EAAGA,EAAIU,EAASK,OAAQf,IAAK,CACtC,MAAMgB,EAAON,EAASV,GAGtB,IAA8B,IAA1BgB,EAAKE,QAAQ,WAAmD,IAAhCF,EAAK,GAAGE,QAAQ,UAKpD,IAHIwB,GAAgC,IAAhB1B,EAAKD,QAAgC,IAAhBC,EAAKD,QAC1CD,EAASG,KAAKD,IAEU,IAAxBA,EAAKE,QAAQ,UAAe,CAC5B,IAAIK,EAAOzB,KAAKqB,WAAWH,GAC3BJ,EAAIlD,OAAOuD,KAAKM,GAChBmB,GAAc,CACjB,MACyB,IAAhB1B,EAAKD,QAAgC,IAAhBC,EAAKD,SAAiC,IAAhB2B,IACjDA,GAAc,EACd9B,EAAInD,UAAUwD,KAAKH,GACnBA,EAAW,GAGlB,CAEDF,EAAIP,MAAQO,EAAInD,UAAUsD,OAC1BjB,KAAKxC,KAAK2D,KAAKL,EAClB,CAOD,QAAA+B,CAASnF,EAAMD,EAAOkD,GAClB,IAAImC,EAAOpF,EAAKmD,MAAM,MAAOkC,GAAM,EAAOC,GAAM,EAAOb,GAAM,EACzDrB,EAAM,CACFH,MAAOA,EACPlD,MAAOA,EACP2B,KAAM,CAAE,EACRxB,OAAQ,GACRD,UAAW,GACXD,KAAMA,EACN8C,KAAM,OAGS,IAAnBsC,EAAK,GAAG7B,QAAmC,IAAnB6B,EAAK,GAAG7B,SAAc8B,GAAM,GACxD,IAAK,IAAI7C,EAAI,EAAGA,EAAI4C,EAAK7B,OAAQf,IAAK,CAClC,IAAIgB,EAAO4B,EAAK5C,IAEJ,IAAR8C,GAAgC,IAAhB9B,EAAKD,QAAgC,IAAhBC,EAAKD,QAC1CH,EAAInD,UAAUwE,GAAGhB,KAAKD,IAEd,IAAR6B,IACAjC,EAAIlD,OAAOuD,KAAKnB,KAAKqB,WAAWH,IAChC6B,GAAM,EACNC,GAAM,EACNb,IACArB,EAAInD,UAAUwE,GAAK,IAEH,IAAhBjB,EAAKD,QAAgC,IAAhBC,EAAKD,SAC1B8B,GAAM,EACNC,GAAM,EAEb,CAEDlC,EAAIP,MAAQO,EAAInD,UAAUsD,OAC1BjB,KAAKxC,KAAK2D,KAAKL,EAClB,CAOD,QAAAmC,CAASvF,EAAMD,EAAOkD,GACf,IAACmC,EAAOpF,EAAKmD,MAAM,MAAOqC,EAAS,KAClCpC,EAAM,CACFH,MAAOA,EACPlD,MAAOA,EACP2B,KAAM,CAAE,EACRxB,OAAQ,GACRD,UAAW,GACX4C,MAAO,KACP7C,KAAMA,EACN8C,KAAM,OAGd,IAAK,IAAIN,EAAI,EAAGA,EAAI4C,EAAK7B,OAAQf,IAAK,CAClC,MAAMgB,EAAO4B,EAAK5C,GAClB,IAAIqC,EAEJ,GAAgB,MAAZrB,EAAK,GAGLqB,EAAUrB,EAAKa,UAAU,EAAGb,EAAKE,QAAQ,KAAO,GAAG+B,mBAEnD,GAAgB,WAAZZ,EAAsB,CACtB,IAAIa,EAASlC,EAAKL,MAAM,KACxB,GAAIuC,EAAOnC,OAAS,EAAG,CACnB,IAAK,IAAIZ,EAAI,EAAGA,EAAI+C,EAAOnC,OAAQZ,IAC/B+C,EAAO,IAAM,IAAMA,EAAO/C,GAG9B+C,EAAOC,OAAO,EAAGD,EAAOnC,OAC3B,CACD,IAAIqC,EAAcF,EAAO,GAAGD,cACxBI,EAAWH,EAAO,GAGtB,GAAoB,WAAhBE,EACAJ,EAASK,EAASJ,cAActC,MAAM,UAErC,GAAoB,aAAhByC,EAA4B,CAKjC,IAAIE,EAAmBD,EAAS1C,MAAM,KAGtCsB,EAAIe,EAAO/C,WAAUC,GAAkB,SAAbA,EAAEqD,SAC5B,IAAIC,EAASF,EAAiBrB,GAG9BwB,GAAKT,EAAO/C,WAAUC,GAAgC,UAA3BA,EAAE+C,cAAcM,SAC3CG,GAAKV,EAAO/C,WAAUC,GAAgC,QAA3BA,EAAE+C,cAAcM,SAE3CI,GAAK7D,KAAKoC,cAAcoB,EAAiBG,KACzCG,GAAK9D,KAAKoC,cAAcoB,EAAiBI,KAEzC9C,EAAIlD,OAAOuD,KAAK,CAAC0C,GAAIC,KACrBhD,EAAInD,UAAUwD,KAAK,CAACuC,GACvB,CACJ,MACI,GAAgB,gBAAZnB,EAA2B,CAChC,GAAgB,MAAZrB,EAAK,GAAY,SACrBkC,OAASlC,EAAKL,MAAM,KACpByC,YAAcF,OAAO,GACrBtC,EAAI1B,KAAKkE,aAAeF,OAAO,EAClC,CAER,CAEDtC,EAAIP,MAAQO,EAAInD,UAAUsD,OAC1BjB,KAAKxC,KAAK2D,KAAKL,EAClB,CAOD,OAAAiD,CAAQrG,EAAMD,EAAOkD,GACjB,IAAImC,EAAOpF,EAAKmD,MAAM,SAAU0B,EAAU,GACtCzB,EAAM,CACFH,MAAOA,EACPlD,MAAOA,EACP2B,KAAM,CAAE,EACRxB,OAAQ,GACRD,UAAW,GACX4C,MAAO,KACP7C,KAAMA,EACN8C,KAAM,MAIdsC,EAAKkB,QAELlB,EAAKA,EAAK7B,OAAS,GAAK6B,EAAKA,EAAK7B,OAAS,GAAGJ,MAAM,WAAW,GAE/D,IAAK,IAAIX,EAAI,EAAGA,EAAI4C,EAAK7B,OAAQf,IAAK,CAClCqC,EAAUO,EAAK5C,GAAGW,MAAM,YACxBY,KAAOc,EAAQ,GAAG1B,MAAM,UAAU,GAAGA,MAAM,MAAM,GAAGA,MAAM,KAC1Dc,QAAU,GACV,IAAK,IAAItB,EAAI,EAAGA,EAAIoB,KAAKR,OAAQZ,IAAK,CAClC,MAAMuB,EAAUH,KAAKpB,GAAGQ,MAAM,KAC9BoD,KAAOrC,EAAQ,GAAGuB,cAClBe,OAAStC,EAAQ,GAAGK,WAAW,IAAK,IACvB,UAATgC,KACAtC,QAAQ,GAAKwC,WAAWD,QAEV,QAATD,OACLtC,QAAQ,GAAKwC,WAAWD,QAE/B,MAGyCrC,IAAtCf,EAAIlD,OAAOkD,EAAIlD,OAAOqD,OAAS,IAAiE,IAA7CH,EAAIlD,OAAOkD,EAAIlD,OAAOqD,OAAS,GAAGA,QACrFH,EAAIlD,OAAOkD,EAAIlD,OAAOqD,OAAS,GAAGE,KAAKQ,QAAQ,IAEnDb,EAAIlD,OAAOuD,KAAKQ,SAChBb,EAAInD,UAAUwD,KAAKoB,EAAQ,GAAG1B,MAAM,QACvC,CAEDC,EAAIP,MAAQO,EAAInD,UAAUsD,OAC1BjB,KAAKxC,KAAK2D,KAAKL,EAClB,CAOD,QAAAsD,CAAS1G,EAAMD,EAAOkD,GACf,IAACmC,EAAOpF,EAAKmD,MAAM,UAAU,GAAGA,MAAM,WAAW,GAAGA,MAAM,OAAiBwD,EAAW,KACrFvD,EAAM,CACFH,MAAOA,EACPlD,MAAOA,EACP2B,KAAM,CAAE,EACRxB,OAAQ,GACRD,UAAW,GACX4C,MAAO,KACP7C,KAAMA,EACN8C,KAAM,OACP8D,EAAM,KAAMC,EAAa,KAEhC,IAAK,IAAIrE,EAAI,EAAGA,EAAI4C,EAAK7B,OAAQf,IAAK,CAClC,GAAmB,MAAf4C,EAAK5C,GAAG,GAAY,SAExB,MAAMsE,EAAO1B,EAAK5C,GAAGW,MAAM,KAG3ByD,EAAME,EAAK,GAAG3D,MAAM,KAGpBwD,EAAW,CAACrE,KAAKoC,cAAckC,EAAI,IAAKtE,KAAKoC,cAAckC,EAAI,KAG/DD,EAAS,IAAMA,EAAS,GAGxBG,EAAKR,QAEL,IAAIhD,EAAW,GAGf,IAAK,IAAIX,EAAI,EAAGA,EAAImE,EAAKvD,OAAQZ,IAAK,CAIlCkE,EAHeC,EAAKnE,GAGA4B,WAAW,MAAO,MAEtC,IAAK,IAAIE,EAAI,EAAGA,EAAIoC,EAAWtD,SACvBsD,EAAWpC,GAAKoC,EAAWpC,EAAI,GAAKoC,EAAWpC,EAAI,GAAKoC,EAAWpC,EAAI,GAAKoC,EAAWpC,EAAI,KAAO,SAAWoC,EAAWpC,GAAKoC,EAAWpC,EAAI,KAAO,MADpHA,IAK/BnB,GAAYuD,EAAWpC,EAGlC,CACDnB,EAAWA,EAASH,MAAM,MAC1BC,EAAIlD,OAAOuD,KAAKkD,GAChBvD,EAAInD,UAAUwD,KAAKH,EACtB,CAEDF,EAAIP,MAAQO,EAAInD,UAAUsD,OAC1BjB,KAAKxC,KAAK2D,KAAKL,EAClB,CAOD,QAAA2D,CAAS/G,EAAMD,EAAOkD,GAClB,IAAIvB,EAAO1B,EAAKmD,MAAM,cAAc,GAAGA,MAAM,eAAe,GACxDiC,EAAOpF,EAAKmD,MAAM,eAAe,GAAGA,MAAM,gBAAgB,GAAGA,MAAM,cACnEC,EAAM,CACFH,MAAOA,EACPlD,MAAOA,EACPG,OAAQ,GACRwB,KAAM,CAAE,EACRzB,UAAW,GACX4C,MAAO,KACP7C,KAAMA,EACN8C,KAAM,OACPkE,EAAQ,GAAIC,EAAQ,GAAIC,GAAM,EAAOC,EAAW,CAAC,KAAM,MAU9D,IANgC,IAA5BzF,EAAKgC,QAAQ,aACbN,EAAI1B,KAAK3B,MAAQ2B,EAAKyB,MAAM,WAAW,GAAGA,MAAM,YAAY,KAEjC,IAA3BzB,EAAKgC,QAAQ,YACbN,EAAI1B,KAAK0F,KAAO1F,EAAKyB,MAAM,UAAU,GAAGA,MAAM,WAAW,KAE5B,IAA7BzB,EAAKgC,QAAQ,YAAoB,CACjC,IAAI2D,EAAa3F,EAAKyB,MAAM,YAAY,GAAGA,MAAM,aAAa,IACzB,IAAjCkE,EAAW3D,QAAQ,YACnBN,EAAI1B,KAAK4F,WAAaD,EAAWlE,MAAM,UAAU,GAAGA,MAAM,WAAW,KAErC,IAAhCkE,EAAW3D,QAAQ,WACnBN,EAAI1B,KAAK6F,UAAYF,EAAWlE,MAAM,SAAS,GAAGA,MAAM,UAAU,KAEhC,IAAlCkE,EAAW3D,QAAQ,aACnBN,EAAI1B,KAAK8F,YAAcH,EAAWlE,MAAM,WAAW,GAAGA,MAAM,YAAY,GAE/E,EACiC,IAA9BzB,EAAKgC,QAAQ,eACbN,EAAI1B,KAAK+F,SAAW,GACpBC,EAAIhG,EAAKyB,MAAM,cAAc,GAAGA,MAAM,eAAe,GACrDC,EAAI1B,KAAK+F,SAAWC,EAAErD,UAAUqD,EAAEhE,QAAQ,KAAO,EAAGgE,EAAEnE,SAG1D,IAAK,IAAIf,EAAI,EAAGA,EAAI4C,EAAK7B,OAAQf,IAAK,CAClC,GAAmB,MAAf4C,EAAK5C,GAAG,GAAY,SAExB,MAAMgB,EAAO4B,EAAK5C,GACZmE,EAAWvB,EAAK5C,GAAGW,MAAM,KAAK,GAAGA,MAAM,KAC7C,IAAIwE,EAAQrF,KAAKoC,cAAciC,EAAS,IACpCiB,EAAMtF,KAAKoC,cAAciC,EAAS,KAIP,IAA3BnD,EAAKE,QAAQ,WACbyD,EAAS,GAAK,SACdA,EAAS,GAAK,YAEqB,IAA9B3D,EAAKE,QAAQ,eAClByD,EAAS,GAAK,YACdA,EAAS,GAAK,cAIlBF,EAAQzD,EAAKL,MAAMgE,EAAS,IAAI,GAAGhE,MAAMgE,EAAS,IAAI,GACtDH,EAAQ,GACRE,GAAM,EACN,IAAK,IAAIzC,EAAIwC,EAAMvD,QAAQ,KAAMe,EAAIwC,EAAM1D,OAAQkB,IAAK,CACpD,MAAMP,EAAU+C,EAAMxC,GAEL,MAAbwC,EAAMxC,IAA+B,MAAjBwC,EAAMxC,EAAI,KAC9ByC,GAAM,GAGNA,IACAF,GAAS9C,GAIG,MAAZA,IACAgD,GAAM,EAGb,CAGD,IAAIW,EAAMzE,EAAIlD,OAAOuC,WAAUC,GAAKiF,GAASjF,EAAE,IAAMiF,GAASjF,EAAE,MACpD,IAARmF,EACAzE,EAAInD,UAAU4H,GAAOzE,EAAInD,UAAU4H,GAAKC,OAAOd,EAAM7D,MAAM,QAG3DC,EAAInD,UAAUwD,KAAKuD,EAAM7D,MAAM,OAC/BC,EAAIlD,OAAOuD,KAAK,CAACkE,EAAOC,IAE/B,CAEDxE,EAAIP,MAAQO,EAAInD,UAAUsD,OAC1BjB,KAAKxC,KAAK2D,KAAKL,EAClB,CAOD,UAAA2E,CAAW/H,EAAMD,EAAOkD,GACpB,IAAImC,EAAOpF,EAAKmD,MAAM,MAClBC,EAAM,CACFH,MAAOA,EACPlD,MAAOA,EACP2B,KAAM,CAAE,EACRxB,OAAQ,GACRD,UAAW,GACX4C,MAAO,KACP7C,KAAMA,EACN8C,KAAM,SAKVpB,EAAO0D,EAAK,GAAGjC,MAAM,MACzBzB,EAAKkD,MACL,IAAK,IAAIjC,EAAI,EAAGA,EAAIjB,EAAK6B,OAAQZ,IAAK,CAClC,MAAMuB,EAAUxC,EAAKiB,GAAGQ,MAAM,KAC9BC,EAAI1B,KAAKwC,EAAQ,IAAMA,EAAQ,EAClC,CAEDd,EAAI1B,KAAKsG,MAAQ,GAEjB,IAAK,IAAIxF,EAAI,EAAGA,EAAI4C,EAAK7B,OAAQf,IAAK,CAClC,MAAMqC,EAAUO,EAAK5C,GAAGW,MAAM,MAO9BC,EAAI1B,KAAKsG,MAAMvE,KAAKoB,EAAQ,IAC5BA,EAAQyB,QACRlD,EAAIlD,OAAOuD,KAAKnB,KAAKqB,WAAWkB,EAAQ,KACxCA,EAAQyB,QAC4B,KAAhCzB,EAAQA,EAAQtB,OAAS,IAAWsB,EAAQD,MAEhDxB,EAAInD,UAAUwD,KAAKoB,EACtB,CAEDzB,EAAIP,MAAQO,EAAInD,UAAUsD,OAC1BjB,KAAKxC,KAAK2D,KAAKL,EAClB,CAOD,QAAA6E,CAASjI,EAAMD,EAAOkD,GAClB,IAAImC,EAAOpF,EAAKmD,MAAM,MAClBC,EAAM,CACFH,MAAOA,EACPlD,MAAOA,EACP2B,KAAM,CAAE,EACRxB,OAAQ,GACRD,UAAW,GACX4C,MAAO,KACP7C,KAAMA,EACN8C,KAAM,OAMd,IAAK,IAAIN,EAAI,EAAGA,EAAI4C,EAAK7B,OAAQf,IAAK,CAClC,GAAuB,IAAnB4C,EAAK5C,GAAGe,QAAmC,IAAnB6B,EAAK5C,GAAGe,OAAc,SAClD,MAAMC,EAAO4B,EAAK5C,GAAGW,MAAM,KAAK,GAAGA,MAAM,KACzC,IAAI+E,EAAU1E,EAAK,GACf2E,EAAO3E,EAAK,IAEiB,IAA7B3D,EAAK6D,QAAQwE,EAAQ,KAErBE,KAAOF,EAAQ7D,UAAU,EAAG6D,EAAQxE,QAAQ,MAC5C2E,IAAMH,EAAQ7D,UAAU6D,EAAQxE,QAAQ,KAAO,EAAGwE,EAAQ3E,QAC7C,OAAT6E,OAAeA,KAAO,UACb,OAATA,OAAeA,KAAO,UACb,OAATA,OAAeA,KAAO,SACb,OAATA,OAAeA,KAAO,SAC1BhF,EAAI1B,KAAK0G,MAAQC,MAGjBtE,KAAOzB,KAAKoC,cAAcwD,GAC1BzD,EAAIrB,EAAIlD,OAAOuD,KAAK,CAACM,OACrBX,EAAInD,UAAUwD,KAAK,CAAC0E,SAEMhE,IAAtBf,EAAIlD,OAAOuE,EAAI,IACfrB,EAAIlD,OAAOuE,EAAI,GAAGhB,KAAKM,MAGlC,CACDX,EAAIlD,OAAOkD,EAAIlD,OAAOqD,OAAS,GAAGE,KAAK6E,KAEvClF,EAAIP,MAAQO,EAAInD,UAAUsD,OAC1BjB,KAAKxC,KAAK2D,KAAKL,EAClB,CASD,aAAAmF,CAAcC,EAAMC,EAAWC,GAC3BD,EAAYA,GAAa,IACzBC,EAAiBA,GAAkB,IACnC,IAAIC,EAAQC,KAAKC,MAAML,EAAO,MAC9BA,GAAuB,KAARG,EACf,IAAIG,EAAUF,KAAKC,MAAML,EAAO,IAE5BO,GADJP,GAAyB,GAAVM,GACIE,QAAQ,GAG3B,OAFAD,EAAUA,EAAQhE,QAAQ,IAAK2D,GAExBC,EAAQF,EAAYK,EAAUL,EAAYM,CACpD,CAOD,aAAArE,CAAc8D,GACP,IAAsBG,EAAOG,EAASC,EAArCE,EAAM,EACNC,EAAMV,EAAKrF,MAAM,KA6BrB,OAzBmB,IAAf+F,EAAI3F,QAKJ2F,EAAI,GAAKA,EAAI,GAAGnE,QAAQ,IAAK,KAG7B4D,EAAQlC,WAAWyC,EAAI,IACvBJ,EAAUrC,WAAWyC,EAAI,IACzBH,EAAUtC,WAAWyC,EAAI,MAGzBA,EAAI,GAAKA,EAAI,GAAGnE,QAAQ,IAAK,KAI7B4D,EAAQ,EACRG,EAAUrC,WAAWyC,EAAI,IACzBH,EAAUtC,WAAWyC,EAAI,KAI7BD,GAAgB,KAARN,EAA2B,GAAVG,EAAgBC,EAElCE,CACV,CAOD,UAAAtF,CAAWwF,GACP,IAAIpF,EAAO,CAAC,EAAG,GAUf,OANAoF,GAAsC,IAA5BA,EAAQzF,QAAQ,MAAeyF,EAAQhG,MAAM,WAAQgG,EAAQzF,QAAQ,UAAgByF,EAAQhG,MAAM,KAAOgG,EAAQhG,MAAM,UAGlIY,EAAK,GAAKzB,KAAKoC,cAAcyE,EAAQ,IACrCpF,EAAK,GAAKzB,KAAKoC,cAAcyE,EAAQ,IAE9BpF,CACV,CAID,MAAAqF,GACI,GAAkB,OAAd9G,KAAKX,KACL,OAAO0H,QAAQC,KAAK,2FAExB,GAA2B,IAAvBhH,KAAKpC,OAAOqD,QAA0C,IAA1BjB,KAAKrC,UAAUsD,SAAmC,IAAnBjB,KAAKL,UAAqB,OAEzF,IAAI9B,EAAUmC,KAAKV,MAAM2H,YAAcjH,KAAKH,YAClCG,KAAKV,MAAM4H,IAErB,IAAK,IAAIhH,EAAI,EAAGA,EAAIF,KAAKpC,OAAOqD,OAAQf,IAAK,CACzC,MAAMuB,EAAOzB,KAAKpC,OAAOsC,GACnBxC,EAAOsC,KAAKrC,UAAUuC,GAG5B,GAFArC,GAAWmC,KAAKjC,OAEZF,GAAW4D,EAAK,IAAM5D,GAAW4D,EAAK,GAGtC,GAFAzB,KAAKnC,QAAUqC,EAEG,IAAdF,KAAKX,KACLW,KAAKb,UAAUgI,UAAYnH,KAAKrC,UAAUqC,KAAKnC,aAE9C,CAED,IAAII,EAAS+B,KAAKhC,MAAMC,QAAU,QAC9BD,EAAQgC,KAAKhC,MAAMA,OAAS,SAC5BI,EAAU4B,KAAKhC,MAAMI,SAAW,SAChCW,EAAOiB,KAAKhC,MAAMe,MAAQ,GAC1BC,EAAOgB,KAAKhC,MAAMgB,MAAQ,GAC1Bd,EAAO8B,KAAKhC,MAAME,MAAQ,GAC1BI,EAAQ0B,KAAKhC,MAAMM,OAAS,SAC5BD,EAAQ2B,KAAKhC,MAAMK,OAAS,QACvB2B,KAAKhC,MAAMoJ,GACpB,IAAI7I,EAAYyB,KAAKhC,MAAMO,WAAa,MACpCI,EAAUqB,KAAKhC,MAAMW,SAAW,EAChCM,EAASe,KAAKhC,MAAMiB,QAAU,OACpBe,KAAKhC,MAAMqJ,WACXrH,KAAKhC,MAAMsJ,UACzB,IAAI9I,EAAewB,KAAKhC,MAAMQ,cAAgB,QAC1CC,EAAcuB,KAAKhC,MAAMS,aAAe,EACxCC,EAAcsB,KAAKhC,MAAMU,aAAe,gBACxCG,EAAUmB,KAAKhC,MAAMa,SAAW,EAChCC,EAAUkB,KAAKhC,MAAMc,SAAW,EAChCF,EAAaoB,KAAKhC,MAAMY,YAAc,EACtCT,EAAc6B,KAAKhC,MAAMG,aAAe,EACxCoJ,EAAavH,KAAKhC,MAAMuJ,WAE5BvH,KAAKd,SAASsI,YACd,IAAIC,EAAKzH,KAAKd,SAASwI,OAAOC,MAAQ,IAAO3I,EACzC4I,EAAK5H,KAAKd,SAASwI,OAAOG,OAAS,IAAO9I,EAE9CiB,KAAKd,SAAS4I,UAAYzJ,EAC1B2B,KAAKd,SAAS6I,UAAYzJ,EAC1B0B,KAAKd,SAASX,UAAYA,EAC1ByB,KAAKd,SAAS8I,KAAO,GAAGhK,KAASI,KAAWa,KAAUf,OAAUD,IAChE+B,KAAKd,SAASR,YAAcA,EAC5BsB,KAAKd,SAASN,WAAaA,EAC3BoB,KAAKd,SAAS+I,cAAgBpJ,EAC9BmB,KAAKd,SAASgJ,cAAgBpJ,EAC9BkB,KAAKd,SAASiJ,YAAcxJ,EAK5B,IAAK,IAAI0B,EAAI3C,EAAKuD,OAAS,EAAGZ,GAAI,EAAIA,IAAK,CACvC,MAAMa,EAAOxD,EAAK2C,GAElBL,KAAKd,SAASkJ,YAAc5J,EAC5BwB,KAAKd,SAASmJ,UAA0B,EAAd5J,EAC1BuB,KAAKd,SAASoJ,WAAWpH,EAAMuG,EAAGG,GAClC5H,KAAKd,SAASmJ,UAAY,EAC1BrI,KAAKd,SAASqJ,SAASrH,EAAMuG,EAAGG,GAChCA,GAAML,EAAapJ,CACtB,CAED6B,KAAKd,SAASsJ,WACjB,CAER,CACJ,CAOD,OAAAC,CAAQf,EAAQpI,GAEZU,KAAKd,SAAWwI,aAAkBgB,yBAA2BhB,EAASA,EAAOhI,WAAW,MACxFM,KAAKX,KAAO,EACZW,KAAKV,MAAQA,CAChB,CAMD,cAAAqJ,CAAe5C,EAAKzG,GAChBU,KAAKb,UAAY4G,EACjB/F,KAAKX,KAAO,EACZW,KAAKV,MAAQA,CAChB,CAKD,SAAAsJ,CAAU7K,GACNiC,KAAKjC,OAA2B,iBAAXA,GAAwB8K,MAAM9K,GAAmBiC,KAAKjC,OAAdA,CAChE,CAKD,QAAA+K,CAASC,GACL/I,KAAKH,YAA+B,iBAAVkJ,GAAuBF,MAAME,GAAiB/I,KAAKH,YAAbkJ,CACnE,CAOD,GAAAC,CAAIhL,EAAOiL,GAEP,OAAQjL,GACJ,IAAK,SACDgC,KAAKhC,MAAMC,OAASgL,EACpBjJ,KAAKS,iBACL,MACJ,IAAK,QACDT,KAAKhC,MAAMK,MAAQ4K,EACnB,MACJ,IAAK,SACDjJ,KAAKhC,MAAMiB,OAASgK,EACpB,MACJ,IAAK,QACDjJ,KAAKhC,MAAMA,MAAQiL,EACnB,MACJ,IAAK,UACDjJ,KAAKhC,MAAMI,QAAU6K,EACrB,MACJ,IAAK,OACDjJ,KAAKhC,MAAME,KAAOiG,WAAW8E,GAC7BjJ,KAAKS,iBACL,MACJ,IAAK,QACDT,KAAKhC,MAAMM,MAAQ2K,EACnB,MACJ,IAAK,YACDjJ,KAAKhC,MAAMO,UAAY0K,EACvB,MACJ,IAAK,QACDjJ,KAAKhC,MAAMa,QAAUsF,WAAW8E,GAChC,MACJ,IAAK,QACDjJ,KAAKhC,MAAMc,QAAUqF,WAAW8E,GAChC,MACJ,IAAK,WACDjJ,KAAKhC,MAAMY,WAAaqK,EACxB,MACJ,IAAK,YACDjJ,KAAKhC,MAAMU,YAAcuK,EACzB,MACJ,IAAK,KACDjJ,KAAKhC,MAAMoJ,GAAK6B,EAChB,MACJ,IAAK,eACDjJ,KAAKhC,MAAMQ,aAAeyK,EAC1B,MACJ,IAAK,cACDjJ,KAAKhC,MAAMS,YAAc0F,WAAW8E,GACpC,MACJ,IAAK,cACDjJ,KAAKhC,MAAMG,YAAcgG,WAAW8E,GACpC,MACJ,IAAK,OACDjJ,KAAKhC,MAAMe,KAAOoF,WAAW8E,GAC7B,MACJ,IAAK,OACDjJ,KAAKhC,MAAMgB,KAAOmF,WAAW8E,GAC7B,MACJ,IAAK,UACDjJ,KAAKhC,MAAMW,QAAUkK,MAAM1E,WAAW8E,IAAU,EAAI9E,WAAW8E,GAG1E,CAKD,cAAAxI,GACI,IAAIyI,EAAW/E,WAAWnE,KAAKhC,MAAME,MACjCiL,EAAanJ,KAAKhC,MAAMC,OAGxBmL,EAAUpJ,KAAKT,IACnB6J,EAAQ1B,OAAOC,MAAQyB,EAAQ1B,OAAOC,MAEtCyB,EAAQC,SAAS,EAAG,EAAGD,EAAQ1B,OAAOC,MAAOyB,EAAQ1B,OAAOG,QAC5DuB,EAAQE,aAAe,MAEvBF,EAAQpB,KAAOkB,EAAW,MAAQC,EAClCC,EAAQtB,UAAY,QAEpBsB,EAAQb,SAVI,KAUY,EAAG,GAE3B,IAAIzF,EAAOsG,EAAQG,aAAa,EAAG,EAAGH,EAAQ1B,OAAOC,MAAOyB,EAAQ1B,OAAOG,QAAQ/E,KAE/E0G,GAAQ,EACRlE,GAAM,EACV,IAAK,IAAIpF,EAAI,EAAGA,EAAIkJ,EAAQ1B,OAAOG,OAAQ3H,IAEvC,IAAK,IAAIG,EAAI,EAAGA,EAAI+I,EAAQ1B,OAAOC,MAAOtH,IAAK,CAG3C,GAAoB,IAAhByC,EAFyC,GAAhC5C,EAAIkJ,EAAQ1B,OAAOC,MAAQtH,IAExC,EASkB,IAAVmJ,IACAA,EAAQtJ,GAEZ,KACH,CAZG,GAAIG,IAAM+I,EAAQ1B,OAAOC,MAAQ,QAAK6B,EAAc,CAChDlE,EAAMpF,EACNA,EAAIkJ,EAAQ1B,OAAOG,OACnB,KACH,CASR,CAGL7H,KAAKhC,MAAMuJ,WAAajC,EAAMkE,CACjC,CAID,gBAAAC,GACIzJ,KAAKhC,MAAQ,CACTC,OAAQ,QACRC,KAAM,GACNC,YAAa,GACbE,MAAO,mBACPC,MAAO,SACPC,UAAW,MACXC,aAAc,aACdC,YAAa,EACbC,YAAa,gBACbC,QAAS,EACTC,WAAY,EACZC,QAAS,EACTC,QAAS,EACTC,KAAM,GACNC,KAAM,GACNC,OAAQ,GACRjB,MAAO,SACPI,QAAS,SAEhB,CAMD,gBAAAsL,CAAiBC,GAOb,OALI3J,KAAKL,UADY,kBAAVgK,EACUA,GAGC3J,KAAKL,UAEpBK,KAAKL,SACf,CAMD,MAAAiK,CAAOnM,GACH,IAAIyC,EAAIF,KAAKxC,KAAK2C,WAAUC,GAAKA,EAAE3C,QAAUA,IAE7C,OAAU,IAANyC,KAC0B,IAAtBF,KAAKxC,KAAK0C,GAAGI,MACbN,KAAKD,QAEFC,KAAKxC,KAAK6F,OAAOnD,EAAG,GAGlC,CAQD,GAAA2J,CAAIpM,EAAOC,EAAMoM,EAAKnJ,GAClB,GAAmB,iBAARmJ,GAAoC,iBAATpM,GAA+B,KAAVD,EAAc,QAG7D,IADFuC,KAAK+J,MAAMtM,KAMT,UADZqM,EAAMA,EAAI3G,gBACoB,QAAR2G,EAClB9J,KAAKU,SAAShD,EAAMD,EAAOkD,GAEd,SAARmJ,GAA0B,QAARA,EACvB9J,KAAK6C,SAASnF,EAAMD,EAAOkD,GAEd,SAARmJ,GAA0B,QAARA,EACvB9J,KAAKoE,SAAS1G,EAAMD,EAAOkD,GAEd,YAARmJ,GAA6B,WAARA,EAC1B9J,KAAK2C,YAAYjF,EAAMD,EAAOkD,GAEjB,SAARmJ,GAA0B,QAARA,EACvB9J,KAAKiD,SAASvF,EAAMD,EAAOkD,GAEd,SAARmJ,GAA0B,QAARA,EACvB9J,KAAKyE,SAAS/G,EAAMD,EAAOkD,GAEd,SAARmJ,GAA0B,QAARA,EACvB9J,KAAK2F,SAASjI,EAAMD,EAAOkD,GAEd,WAARmJ,GAA4B,UAARA,EACzB9J,KAAKyF,WAAW/H,EAAMD,EAAOkD,GAEhB,QAARmJ,GAAyB,OAARA,EACtB9J,KAAK+D,QAAQrG,EAAMD,EAAOkD,GAEb,UAARmJ,GAA2B,SAARA,GAA0B,SAARA,GAA0B,UAARA,EAC5D9J,KAAKsB,cAAc5D,EAAMD,EAAOkD,GAEnB,SAARmJ,GAA0B,QAARA,GACvB9J,KAAKqC,SAAS3E,EAAMD,EAAOkD,GAElC,CAMD,OAAOqJ,GACH,GAA0B,iBAAfA,EAAyB,OAGpC,IAAItM,GAAO,EA2BX,MAzBmB,UAHnBsM,EAAaA,EAAW7G,gBAGoB,QAAf6G,EACzBtM,EAAOsC,KAAKiK,cAEQ,SAAfD,GAAwC,QAAfA,GAGV,SAAfA,GAAwC,QAAfA,IAGV,YAAfA,GAA2C,WAAfA,EACjCtM,EAAOsC,KAAKkK,iBAEQ,SAAfF,GAAwC,QAAfA,EAC9BtM,EAAOsC,KAAKmK,cAEQ,SAAfH,GAAwC,QAAfA,IAGV,SAAfA,GAAwC,QAAfA,EAC9BtM,EAAOsC,KAAKoK,cAEQ,WAAfJ,GAA0C,UAAfA,IAChCtM,EAAOsC,KAAKqK,mBAGT3M,CACV,CAMD,KAAAqM,CAAMtM,GAEF,OAAc,IADFuC,KAAKxC,KAAK2C,WAAUC,GAAKA,EAAE3C,QAAUA,MAE7CsJ,QAAQC,KAAK,oBAAsBvJ,EAAQ,iDACpC,EAGd,CAKD,WAAAwM,GACI,IAAIvM,EAAO,GACX,IAAK,IAAIwC,EAAI,EAAGA,EAAIF,KAAKrC,UAAUsD,OAAQf,IAAK,CAC5C,MAAMY,EAAMd,KAAKrC,UAAUuC,GACrBuB,EAAOzB,KAAKpC,OAAOsC,GACzB,IAAIsE,EAAQtE,EAAI,EAAK,KACrBsE,GAAQxE,KAAKiG,cAAcxE,EAAK,GAAI,IAAK,KAAO,WAAUzB,KAAKiG,cAAcxE,EAAK,GAAI,IAAK,KAAO,KAElG+C,GAAQ1D,EAAIwJ,KAAK,MAEjB5M,GAAQ8G,EAAO,IAClB,CAED,OAAO9G,CACV,CAKD,cAAAwM,GACI,IAAIxM,EAAO,WAEX,IAAK,IAAIwC,EAAI,EAAGA,EAAIF,KAAKrC,UAAUsD,OAAQf,IAAK,CAC5C,MAAMY,EAAMd,KAAKrC,UAAUuC,GACrBuB,EAAOzB,KAAKpC,OAAOsC,GACzB,IAAIsE,EAAQtE,EAAI,EAAK,KACrBsE,GAAQxE,KAAKiG,cAAcxE,EAAK,IAAM,WAAUzB,KAAKiG,cAAcxE,EAAK,IAAM,KAE9E+C,GAAQ1D,EAAIwJ,KAAK,MAEjB5M,GAAQ8G,EAAO,IAClB,CAED,OAAO9G,CACV,CAKD,aAAA2M,GACI,IAAI3M,EAAO,GAGX,IAAK,MAAM6M,KAAOvK,KAAKZ,KACnB,GAAIY,KAAKZ,KAAKoL,eAAeD,GAAM,CAC/B,MAAM3I,EAAU5B,KAAKZ,KAAKmL,GAC1BE,EAAIF,EAAM,MAAQ3I,EAAU,KAC5BlE,GAAQ+M,CACX,CAEL/M,GAAQ,KACR,IAAIgI,OAA4B7D,IAApB7B,KAAKZ,KAAKsG,MAAsB1F,KAAKZ,KAAKsG,MAAQ,GAG9D,IAAK,IAAIxF,EAAI,EAAGA,EAAIF,KAAKrC,UAAUsD,OAAQf,IAAK,CAC5C,MAAMc,EAAWhB,KAAKrC,UAAUuC,GAC1BuB,EAAOzB,KAAKpC,OAAOsC,GAGzB,IAAIsE,QAFsB3C,IAAb6D,EAAMxF,GAAmBwF,EAAMxF,GAAK,IAE/B,KAClBsE,GAAQxE,KAAKiG,cAAcxE,EAAK,IAAM,KAAOzB,KAAKiG,cAAcxE,EAAK,IAAM,KAE3E+C,GAAQxD,EAASsJ,KAAK,MAEtB5M,GAAQ8G,EAAO,MAClB,CAED,OAAO9G,CACV,CAKD,WAAA0M,GACI,IAAI1M,EAAO,GAEX,IAAK,MAAM6M,KAAOvK,KAAKZ,KACnB,GAAIY,KAAKZ,KAAKoL,eAAeD,GAAM,CAC/B,MAAMtB,EAAQjJ,KAAKZ,KAAKmL,GACxBG,KAAe,WAARH,EAAmB,KAAe,UAARA,EAAkB,KAAe,UAARA,EAAkB,KAAe,WAARA,EAAmB,KAAOA,EAC7G7M,GAAQ,IAAMgN,KAAO,IAAMzB,EAAQ,KACtC,CAGL,IAAK,IAAI/I,EAAI,EAAGA,EAAIF,KAAKrC,UAAUsD,OAAQf,IAAK,CAC5C,MAAMY,EAAMd,KAAKrC,UAAUuC,GAAG,GAE9BxC,GAAQ,IADKsC,KAAKiG,cAAcjG,KAAKpC,OAAOsC,GAAG,IAC1B,IAAMY,EAAM,IACpC,CAED,OAAOpD,CACV,CAKD,WAAAyM,GACIzM,KAAO,kBAEP,IAAK,MAAM6M,KAAOvK,KAAKZ,KACnB,GAAIY,KAAKZ,KAAKoL,eAAeD,GAAM,CAC/B,MAAM3I,EAAU5B,KAAKZ,KAAKmL,GAC1B7M,MAAQ6M,EAAM,KAAO3I,EAAU,IAClC,CAELlE,MAAQ,KAGRA,MAAQ,aAERA,MAAQ,mCACR,IAAIgI,OAA4B7D,IAApB7B,KAAKZ,KAAKsG,MAAsB1F,KAAKZ,KAAKsG,MAAQ,GAE9D,IAAK,IAAIxF,EAAI,EAAGA,EAAIF,KAAKrC,UAAUsD,OAAQf,IAAK,CAC5C,MAAMY,EAAMd,KAAKrC,UAAUuC,GACrBwC,EAAQ1C,KAAKiG,cAAcjG,KAAKpC,OAAOsC,GAAG,IAC1CyK,EAAQ3K,KAAKiG,cAAcjG,KAAKpC,OAAOsC,GAAG,IAC1CwK,OAAoB7I,IAAb6D,EAAMxF,GAAmBwF,EAAMxF,GAAK,UAEjDxC,MAAQ,aAAegF,EAAQ,IAAMiI,EAAQ,IAAMD,EAAO,IAAM5J,EAAM,IACzE,CAED,OAAOpD,IACV,CAMD,YAAAkN,CAAapJ,QACeK,IAApB7B,KAAKZ,KAAKmC,OACNvB,KAAKZ,KAAKmC,MAAMiJ,eAAehJ,KAC/BxB,KAAKrC,UAAYqC,KAAKZ,KAAKmC,MAAMC,GAG5C"}