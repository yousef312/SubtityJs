{"version":3,"file":"subtity.umd.min.js","sources":["../src/subtity.js"],"sourcesContent":["\r\n/**\r\n * Subtity.js 3.1.0\r\n *\r\n * Copyright 2021, yousef neji\r\n * Licensed under the MIT license.\r\n */\r\n/**\r\n * @tutorial\r\n * How to use this library?\r\n * First this library is basically created to used through a rendering process, means for exmaple\r\n * you are rendering a video using a CanvasRenderingContext2d and you want to add subtitles, so you\r\n * can simplye instantiate the class then init it using setUp2D method passing the canvas element or the \r\n * context to render to, then you add the line `Subtity.update()` inside the rendering loop. and that's it\r\n * you can later on use the method `subtity.add()` to add new subtitle passing the text content of the file\r\n * and the extension and the title of the subtitle that going to identify it.\r\n * The system will store any parse subtitle and later on you can switch between using the method `use` passing \r\n * the special title of the subtitle.\r\n */\r\n\r\nvar nums = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\r\n\r\n/**\r\n * A powerfull tool to add subtitles to your movie, it works in two modes, either rendering\r\n * the subtitles to a CanvasRenderingContext2D or directly to the DOM, the style of the text\r\n * is fully accessible to be manipulated using the standard methods defined by the library.\r\n * \r\n * The interface support parsing this files formats:\r\n *  - `webvtt`\r\n *  - `itt`\r\n *  - `ssa`\r\n *  - `srt`\r\n *  - `sbv`\r\n *  - `usf`\r\n *  - `lrc`\r\n *  - `xml`\r\n *  - `rt`\r\n *  - `dfxp`\r\n *  - `ttml`\r\n *  - `subti` official\r\n * \r\n * and exporting this file\r\n *  - `srt`\r\n *  - `subti`\r\n *  - `lrc`\r\n *  - `webvtt`\r\n *  - `ssa`\r\n * @author Yousef Neji\r\n */\r\nfunction Subtity() {\r\n\r\n    /**\r\n     * Holds the different defined subtitles\r\n     * @type {Array}\r\n     */\r\n    this.subs = [];\r\n\r\n    /**\r\n     * The currently used subtitle title used it identify it\r\n     * @type {string}\r\n     */\r\n    this.title = '';\r\n\r\n    /**\r\n     * The text content of the subtitle file currently under use.\r\n     * @readonly\r\n     * @type {string}\r\n     */\r\n    this.text = '';\r\n\r\n    /**\r\n     * Holds the different subtitles strings for file currently under use. \r\n     * @type {array}\r\n     */\r\n    this.subtitles = [];\r\n\r\n    /**\r\n     * Holds the different subtitle ranges of time for file currently under use.\r\n     * @type {array}\r\n     */\r\n    this.ranges = [];\r\n\r\n    /**\r\n     * Holds the current displayed subtitle index in the subtitles list.\r\n     * @type {number}\r\n     * @readonly\r\n     */\r\n    this.current = 0;\r\n\r\n    /**\r\n     * Holds the subtitles counts for file currently under use.\r\n     * @type {number}\r\n     */\r\n    this.subtitlesCounts = null;\r\n\r\n    /**\r\n     * Optional offseting of subtitles ranges, used to synchronous the subtitle with the speech\r\n     * when it's asynchronous.\r\n     * @type {number}\r\n     */\r\n    this.offset = 0;\r\n\r\n    /**\r\n     * Holds the different rendering style options, to change those options use `set` method and\r\n     * don't change them manually as there is extra calculation need to be done.\r\n     */\r\n    this.style = {\r\n        family: 'Arial',\r\n        size: 19,\r\n        style: 'normal',\r\n        lineSpacing: 5,\r\n        variant: 'normal',\r\n        color: 'rgb(255,255,255)',\r\n        align: 'center',\r\n        direction: 'ltr',\r\n        outlineColor: 'rgb(0,0,0)',\r\n        outlineSize: 1,\r\n        shadowColor: 'rgba(0,0,0,0)',\r\n        opacity: 1,\r\n        shadowBlur: 0,\r\n        shadowX: 0,\r\n        shadowY: 0,\r\n        base: 90,\r\n        left: 50,\r\n        weight: ''\r\n    };\r\n\r\n    /**\r\n     * Used to render the subtitle if 2D renderer was chosen, will remain null if html div container was chosen!\r\n     * @type {CanvasRenderingContext2D}\r\n     */\r\n    this.renderer = null;\r\n\r\n    /**\r\n     * Used to holds the HTMLElement used to contain the subtitles, will remain null if 2D was chosen!\r\n     * @type {HTMLElement}\r\n     */\r\n    this.container = null;\r\n\r\n    /**\r\n     * Holds some meta data if any about the subtitle currently under use.\r\n     * @type {object}\r\n     */\r\n    this.meta = {};\r\n\r\n    /**\r\n     * The displaying mode, holds the mode id used in rendering/displaying the subtitles.\r\n     * \r\n     *  - `1` : for HTMLElement displaying mode\r\n     *  - `2` : for 2DCanvasRendering context mode\r\n     * @readonly\r\n     * @type {number}\r\n     */\r\n    this.mode = null;\r\n\r\n    /**\r\n     * The HTMLVideoElement used to show the video with subtitles.\r\n     * @type {HTMLVideoElement}\r\n     */\r\n    this.video = null;\r\n\r\n    /**\r\n     * The Parser owned context, used to perform some critical calculations\r\n     * @type {CanvasRenderingContext2D}\r\n     */\r\n    this.ctx = document.createElement('canvas').getContext('2d');\r\n\r\n    /**\r\n     * Flag determine whether the subtitle displaying currently activated or not\r\n     * @type {boolean}\r\n     */\r\n    this.activated = false;\r\n\r\n    /**\r\n     * Holds the current used subtitle file format or extension\r\n     * @type {String}\r\n     */\r\n    this.currentFileType = null;\r\n\r\n    /**\r\n     * This value controls the speed of the subtitles you can change through `Subtity.setSpeed`.\r\n     * @type {number}\r\n     */\r\n    this.speedFactor = 1;\r\n}\r\nSubtity.prototype = {\r\n    /**\r\n     * Reset the system by freeing the currently used subtitle list and ranges..\r\n     * @method Subtity#reset\r\n     */\r\n    reset: function () {\r\n        this.current = 0;\r\n        this.speedFactor = 1;\r\n        this.offset = 0;\r\n        this.style = {\r\n            family: 'Arial',\r\n            size: 19,\r\n            style: 'normal',\r\n            variant: 'normal',\r\n            lineSpacing: 10,\r\n            color: 'rgb(255,255,255)',\r\n            align: 'center',\r\n            direction: 'ltr',\r\n            outlineColor: 'rgb(0,0,0)',\r\n            outlineSize: 1,\r\n            shadowColor: 'rgba(0,0,0,0)',\r\n            shadowBlur: 0,\r\n            opacity: 1,\r\n            shadowX: 0,\r\n            shadowY: 0,\r\n            base: 90,\r\n            left: 50,\r\n            weight: ''\r\n        };\r\n        this.subtitles = [];\r\n        this.ranges = [];\r\n        this.activated = false;\r\n        this.subtitlesCounts = 0;\r\n        this.meta = {};\r\n        this.title = '';\r\n        this.currentFileType = null;\r\n    },\r\n    /**\r\n     * Use certain subtitle file and activate the rendering\r\n     * @method Subtity#use\r\n     * @param {string} title \r\n     */\r\n    use: function (title) {\r\n        var i = this.subs.findIndex(a => a.title === title);\r\n        if (i === -1) return;\r\n\r\n        if (this.title !== '') {\r\n            var j = this.subs.findIndex(a => a.title === this.title);\r\n            this.subs[j].used = false;\r\n        }\r\n\r\n        this.current = 0;\r\n\r\n        this.reset();\r\n        this.subs[i].used = true;\r\n        this.title = this.subs[i].title;\r\n        this.ranges = this.subs[i].ranges;\r\n        this.subtitles = this.subs[i].subtitles;\r\n        this.text = this.subs[i].text;\r\n        this.subtitlesCounts = this.subs[i].count;\r\n        this.activated = true;\r\n        this.meta = this.subs[i].meta;\r\n        this.currentFileType = this.subs[i].type;\r\n\r\n        this.calcFontHeight();\r\n    },\r\n    /**\r\n     * Parse the given srt file text content, must be called once after starting the video!\r\n     * @method Subtity#parseSRT\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseSRT: function (text, title, movie) {\r\n        var sections = text.split('\\n'),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                ranges: [],\r\n                meta: {},\r\n                subtitles: [],\r\n                text: text,\r\n                count: 0,\r\n                type: 'srt'\r\n            },\r\n            // that's all it is\r\n            isNam = false,\r\n            subtitle = [];\r\n        for (let i = 0; i < sections.length; i++) {\r\n            const line = sections[i];\r\n\r\n            if ((line.length == 1 || line.length === 0) && subtitle.length !== 0) {\r\n                isNam = false;\r\n                sub.subtitles.push(subtitle);\r\n                subtitle = [];\r\n            }\r\n\r\n            if (line.indexOf('-->') !== -1) {\r\n                sub.ranges.push(this.getSeconds(line));\r\n                isNam = true;\r\n            }\r\n            else if (isNam === true && line.length !== 1) {\r\n                subtitle.push(line)\r\n            }\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    },\r\n    /**\r\n     * Parse the given xml based file formats text content like `.dfxp` and `.ttml`, must be called once after starting the video!\r\n     * \r\n     * @method Subtity#parseXMLBased\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseXMLBased: function (text, title, movie) {\r\n        var sections = text.split('<body>')[1].split('</body>')[0].split('</div>'),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {\r\n                    langs: {}\r\n                },\r\n                ranges: [],\r\n                subtitles: [],\r\n                text: text,\r\n                type: 'dfxp'\r\n            }, lang = null,\r\n            rang = null,\r\n            flang = null,\r\n            rangout = null;\r\n\r\n        for (let i = 0; i < sections.length; i++) {\r\n            const element = sections[i].split('<div ')[1];\r\n            if (element === undefined) continue;\r\n\r\n            var keyword = element.substr(0, element.indexOf('>')).split(' ');\r\n\r\n            keyword.forEach((a, i) => {\r\n                keyword[i] = keyword[i].split('=');\r\n                if (keyword[i][0] === 'xml:lang') {\r\n                    lang = keyword[i][1].replaceAll('\"', '');\r\n                    if (flang === null) flang = lang;\r\n                    sub.meta.langs[lang] = [];\r\n                }\r\n            });\r\n\r\n            var lines = element.split('</p>');\r\n            if (lang === null) {\r\n                lang = 'en';\r\n                if (flang === null) flang = lang;\r\n            }\r\n            for (let j = 0; j < lines.length; j++) {\r\n                var line = lines[j].split('<p ')[1];\r\n                if (line === undefined) continue;\r\n                line = line.substr(line.indexOf('>') + 1, line.length);\r\n\r\n                if (i === 0) {\r\n                    rang = line.substr(0, line.indexOf('>')).split(' ');\r\n                    rangout = [];\r\n                    rang.forEach((a, k) => {\r\n                        rang[k] = rang[k].split('=');\r\n                        if (rang[k][0] === 'begin') {\r\n                            rangout[0] = this.convertToTime(rang[k][1].replaceAll('\"', ''));\r\n                        }\r\n                        else if (rang[k][0] === 'end') {\r\n                            rangout[1] = this.convertToTime(rang[k][1].replaceAll('\"', ''));\r\n                        }\r\n                    })\r\n                }\r\n\r\n                sub.ranges.push(rangout);\r\n                sub.meta.langs[lang].push(line.split('<br />'));\r\n            }\r\n        }\r\n\r\n        sub.subtitles = sub.meta.langs[flang];\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    },\r\n    /**\r\n     * Parse the given xml file text content, must be called once after starting the video!\r\n     * @method Subtity#parseXML\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseXML: function (text, title, movie) {\r\n        var sections = text.split('<video>')[1].split('<video/>')[0].split('</title>'),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                text: text,\r\n                type: 'xml'\r\n            };\r\n        sections.pop();\r\n\r\n        for (let i = 0; i < sections.length; i++) {\r\n            const section = sections[i].split('<title>')[1];\r\n            rang0 = this.convertToTime(section.split('<start>')[1].split('</start>')[0].replace(';', '.'));\r\n            rang1 = this.convertToTime(section.split('<end>')[1].split('</end>')[0].replace(';', '.'));\r\n            rang = [rang0, rang1];\r\n            sub.ranges.push(rang);\r\n            subtitle = section.split('<text>')[1].split('</text>')[0].split('<br/>');\r\n            sub.subtitles.push(subtitle);\r\n        }\r\n\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    },\r\n    /**\r\n     * Parse the given webvtt file text content, must be called once after starting the video!\r\n     * @method Subtity#parseWEBVTT\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseWEBVTT: function (text, title, movie) {\r\n        var sections = text.split('\\n'), openSection = false,\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                text: text,\r\n                type: 'webvtt'\r\n            };\r\n        // that's all it is\r\n        var subtitle = [];\r\n        for (let i = 0; i < sections.length; i++) {\r\n            const line = sections[i];\r\n\r\n            // ignoring comments\r\n            if (line.indexOf('NOTE ') !== -1 || line[0].indexOf('NOTE\\n') !== -1) {\r\n                continue;\r\n            }\r\n\r\n            if (openSection && (line.length !== 1 || line.length !== 0)) {\r\n                subtitle.push(line);\r\n            }\r\n\r\n            if (line.indexOf('-->') !== -1) {\r\n                var rang = this.getSeconds(line);\r\n                sub.ranges.push(rang);\r\n                openSection = true;\r\n            }\r\n            else if ((line.length === 1 || line.length === 0) && openSection === true) {\r\n                openSection = false;\r\n                sub.subtitles.push(subtitle);\r\n                subtitle = [];\r\n            }\r\n\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    },\r\n    /**\r\n     * Parse the given .sbv file format and subtract all subtitles and their durations.\r\n     * @method Subtity#parseSBV\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseSBV: function (text, title, movie) {\r\n        var data = text.split('\\n'), off = false, two = false, k = -1,\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                text: text,\r\n                type: 'sbv'\r\n            };\r\n\r\n        if (data[0].length === 1 || data[0].length === 0) off = true;\r\n        for (let i = 0; i < data.length; i++) {\r\n            var line = data[i];\r\n\r\n            if (two === true && line.length !== 1 && line.length !== 0) {\r\n                sub.subtitles[k].push(line);\r\n            }\r\n\r\n            if (off === true) {\r\n                sub.ranges.push(this.getSeconds(line));\r\n                off = false;\r\n                two = true;\r\n                k++;\r\n                sub.subtitles[k] = [];\r\n            }\r\n            if (line.length === 1 || line.length === 0) {\r\n                off = true;\r\n                two = false;\r\n            }\r\n\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    },\r\n    /**\r\n     * Parse the given .ssa file format and subtract all subtitles and their durations.\r\n     * @method Subtity#parseSSA\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseSSA: function (text, title, movie) {\r\n        var data = text.split('\\n'), syntax = null, section = null,\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'ssa'\r\n            };\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n            const line = data[i];\r\n\r\n\r\n            if (line[0] === '[') {\r\n                // that means we enter a section \r\n                // and now we will check what does the section contains\r\n                var section = line.substr(1, line.indexOf(']') - 1).toLowerCase();\r\n            }\r\n            else {\r\n                if (section === 'events') {\r\n                    var pieces = line.split(':');\r\n                    if (pieces.length > 2) {\r\n                        for (let j = 2; j < pieces.length; j++) {\r\n                            pieces[1] += ':' + pieces[j];\r\n                        }\r\n\r\n                        pieces.splice(2, pieces.length);\r\n                    }\r\n                    var lineSubject = pieces[0].toLowerCase();\r\n                    var lineBody = pieces[1];\r\n\r\n                    // line may be a format explain or a dialog\r\n                    if (lineSubject === 'format') {\r\n                        syntax = lineBody.toLowerCase().split(',');\r\n                    }\r\n                    else if (lineSubject === 'dialogue') {\r\n                        // because for dialogs line contains more information then just the text\r\n                        // there is the speaker and some other stuffs and that's ordered according \r\n                        // to the format line we found above\r\n\r\n                        var lineBodySections = lineBody.split(',');\r\n\r\n                        // getting the subtitle\r\n                        k = syntax.findIndex(a => a.trim() === 'text');\r\n                        var string = lineBodySections[k];\r\n\r\n                        // getting the time rang\r\n                        i0 = syntax.findIndex(a => a.toLowerCase().trim() === 'start');\r\n                        i1 = syntax.findIndex(a => a.toLowerCase().trim() === 'end');\r\n\r\n                        t1 = this.convertToTime(lineBodySections[i0]);\r\n                        t2 = this.convertToTime(lineBodySections[i1]);\r\n\r\n                        sub.ranges.push([t1, t2]);\r\n                        sub.subtitles.push([string]);\r\n                    }\r\n                }\r\n                else if (section === 'script info') {\r\n                    if (line[0] === ';') continue; // stands for comments lines\r\n                    pieces = line.split(':');\r\n                    lineSubject = pieces[0];\r\n                    sub.meta[lineSubject] = pieces[1];\r\n                }\r\n            }\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    },\r\n    /**\r\n     * Parse the given .rt file format and subtract all subtitles and their durations.\r\n     * @method Subtity#parseRT\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseRT: function (text, title, movie) {\r\n        var data = text.split('<br/>'), section = [],\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'rt'\r\n            };\r\n\r\n        // taking rid of the useless part\r\n        data.shift();\r\n        // fixing some part\r\n        data[data.length - 1] = data[data.length - 1].split('</font>')[0];\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n            section = data[i].split('<clear/>');\r\n            rang = section[0].split('<time ')[1].split('/>')[0].split(' ');\r\n            rangout = [];\r\n            for (let j = 0; j < rang.length; j++) {\r\n                const element = rang[j].split('=');\r\n                prop = element[0].toLowerCase();\r\n                config = element[1].replaceAll('\"', '');\r\n                if (prop === 'begin') {\r\n                    rangout[0] = parseFloat(config);\r\n                }\r\n                else if (prop === 'end') {\r\n                    rangout[1] = parseFloat(config);\r\n                }\r\n            }\r\n\r\n            // fixing the older rang if missing end property\r\n            if (sub.ranges[sub.ranges.length - 1] !== undefined && sub.ranges[sub.ranges.length - 1].length === 1) {\r\n                sub.ranges[sub.ranges.length - 1].push(rangout[0]);\r\n            }\r\n            sub.ranges.push(rangout);\r\n            sub.subtitles.push(section[1].split('<br>'));\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    },\r\n    /**\r\n     * Parse the given .itt file format and subtract all subtitles and their durations.\r\n     * @method Subtity#parseITT\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseITT: function (text, title, movie) {\r\n        var data = text.split('<body>')[1].split('</body>')[0].split('<p '), pos = 0, timeRang = null,\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'itt'\r\n            }, raw = null, betterText = null;\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (data[i][0] !== 'b') continue; // empty unrecognised line are ignored\r\n\r\n            const sect = data[i].split('>');\r\n\r\n            // getting the time rang that exist inside the p element in the format `start=\"hh:mm:ss.xx\" dur=\"hh:mm:ss.xx\"`\r\n            raw = sect[0].split('\"');\r\n            // now after we split we have the the array with this content ['start','hh:mm:ss.xx','dur','hh:mm:ss.xx']\r\n            // we now convert each indivual cell time\r\n            timeRang = [this.convertToTime(raw[1]), this.convertToTime(raw[3])];\r\n            // because the itt file time definition uses the format `start : dur` \r\n            // instead or `start : end` we need to do the incrimentations so our system could work well\r\n            timeRang[1] += timeRang[0];\r\n            // after we subtract the data from the first array cell it's good to take rid of it\r\n            // so it no more bother us\r\n            sect.shift();\r\n\r\n            var subtitle = '';\r\n            // this step needs to loop through the string to take rid of the span element inside\r\n            // of it and only absord the subtitle pure text\r\n            for (let j = 0; j < sect.length; j++) {\r\n                const string = sect[j];\r\n                // why <br instead of the whole string <br> \r\n                // simply because we take rid of the > when we split the string using it\r\n                betterText = string.replaceAll('<br', '\\n');\r\n\r\n                for (let k = 0; k < betterText.length; k++) {\r\n                    if (betterText[k] + betterText[k + 1] + betterText[k + 2] + betterText[k + 3] + betterText[k + 4] === '<span' || betterText[k] + betterText[k + 1] === '</') {\r\n                        break;\r\n                    }\r\n                    else {\r\n                        subtitle += betterText[k];\r\n                    }\r\n                }\r\n            }\r\n            subtitle = subtitle.split('\\n'); // we split to get the array\r\n            sub.ranges.push(timeRang);\r\n            sub.subtitles.push(subtitle);\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    },\r\n    /**\r\n     * Parse the given .usf file format and subtract all subtitles and their durations.\r\n     * @method Subtity#parseUSF\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseUSF: function (text, title, movie) {\r\n        var meta = text.split('<metadata>')[1].split('</metadata>')[0],\r\n            data = text.split('<subtitles>')[1].split('</subtitles>')[0].split('<subtitle '),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                ranges: [],\r\n                meta: {},\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'usf'\r\n            }, fline = '', sline = '', ino = false, splitter = [null, null];\r\n\r\n\r\n        // getting the meta data\r\n        if (meta.indexOf('<title>') !== -1) {\r\n            sub.meta.title = meta.split('<title>')[1].split('</title>')[0];\r\n        }\r\n        if (meta.indexOf('<date>') !== -1) {\r\n            sub.meta.date = meta.split('<date>')[1].split('</date>')[0];\r\n        }\r\n        if (meta.indexOf('<author>') !== -1) {\r\n            var authorData = meta.split('<author>')[1].split('</author>')[0];\r\n            if (authorData.indexOf('<name>') !== -1) {\r\n                sub.meta.authorName = authorData.split('<name>')[1].split('</name>')[0];\r\n            }\r\n            if (authorData.indexOf('<url>') !== -1) {\r\n                sub.meta.authorUrl = authorData.split('<url>')[1].split('</url>')[0];\r\n            }\r\n            if (authorData.indexOf('<email>') !== -1) {\r\n                sub.meta.authorEmail = authorData.split('<email>')[1].split('</email>')[0];\r\n            }\r\n        }\r\n        if (meta.indexOf('<language') !== -1) {\r\n            sub.meta.language = \"\";\r\n            t = meta.split('<language ')[1].split('</language>')[0];\r\n            sub.meta.language = t.substr(t.indexOf('>') + 1, t.length);\r\n        }\r\n\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (data[i][0] !== 's') continue; // empty recognised lines are ignored\r\n\r\n            const line = data[i];\r\n            const timeRang = data[i].split('>')[0].split('\"');\r\n            var begin = this.convertToTime(timeRang[1]);\r\n            var end = this.convertToTime(timeRang[3]);\r\n\r\n\r\n            // choosing the right splitter\r\n            if (line.indexOf('<text ') !== -1) {\r\n                splitter[0] = '<text ';\r\n                splitter[1] = '</text>';\r\n            }\r\n            else if (line.indexOf('<karaoke ') !== -1) {\r\n                splitter[0] = '<karaoke ';\r\n                splitter[1] = '</karaoke>';\r\n            }\r\n\r\n            // doing the subtraction\r\n            sline = line.split(splitter[0])[1].split(splitter[1])[0];\r\n            fline = '';\r\n            ino = false;\r\n            for (let k = sline.indexOf('>'); k < sline.length; k++) {\r\n                const element = sline[k];\r\n\r\n                if (sline[k] === '<' && sline[k + 1] !== ' ') {\r\n                    ino = false;\r\n                }\r\n\r\n                if (ino) {\r\n                    fline += element;\r\n                }\r\n\r\n\r\n                if (element === '>') {\r\n                    ino = true;\r\n                }\r\n\r\n            }\r\n\r\n            // make sure there is no other subtitle that collides with this one.\r\n            var alr = sub.ranges.findIndex(a => begin >= a[0] && begin <= a[1]);\r\n            if (alr !== -1) {\r\n                sub.subtitles[alr] = sub.subtitles[alr].concat(fline.split('\\n'));\r\n            }\r\n            else {\r\n                sub.subtitles.push(fline.split('\\n'));\r\n                sub.ranges.push([begin, end]);\r\n            }\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    },\r\n    /**\r\n     * Parse the given .subti file format and subtract all subtitles and their durations.\r\n     * @method Subtity#parseSUBTI\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseSUBTI: function (text, title, movie) {\r\n        var data = text.split('=='),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'subti'\r\n            };\r\n\r\n        // now data contains at the first section the meta data\r\n        // so let's subtract it\r\n        var meta = data[0].split('\\n');\r\n        meta.pop();\r\n        for (let j = 0; j < meta.length; j++) {\r\n            const element = meta[j].split('=');\r\n            sub.meta[element[0]] = element[1];\r\n        }\r\n\r\n        sub.meta.names = [];\r\n        // now moving the actual subtitles\r\n        for (let i = 1; i < data.length; i++) {\r\n            const section = data[i].split('\\n');\r\n            // doing this will add two empty cells at the begin and\r\n            // the end of the section array\r\n            // we need to delete them\r\n            // getting the time\r\n            // the first empty cell well it's not totally empty some times ou find the talker name in it\r\n            // so let's save any way\r\n            sub.meta.names.push(section[0]);\r\n            section.shift();// this to delete the empty cell\r\n            sub.ranges.push(this.getSeconds(section[0]));\r\n            section.shift();// to delete the cell containing the time rang\r\n            if (section[section.length - 1] === '') section.pop();  // to delete the last empty cell\r\n            // now the subtitle\r\n            sub.subtitles.push(section);\r\n        }\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    },\r\n    /**\r\n     * Parse the given .lrc file format and subtract all lyric and their durations.\r\n     * @method Subtity#parseLRC\r\n     * @param {string} text the file content\r\n     * @param {string} title the subtitle special name to identify and use later\r\n     * @param {string} movie the movie to display subtitles to\r\n     */\r\n    parseLRC: function (text, title, movie) {\r\n        var data = text.split('\\n'),\r\n            sub = {\r\n                movie: movie,\r\n                title: title,\r\n                meta: {},\r\n                ranges: [],\r\n                subtitles: [],\r\n                count: null,\r\n                text: text,\r\n                type: 'lrc'\r\n            };\r\n        // subtracting meta\r\n\r\n\r\n        // subtracting main\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (data[i].length === 1 || data[i].length === 0) continue;\r\n            const line = data[i].split('[')[1].split(']');\r\n            var descrip = line[0];\r\n            var body = line[1];\r\n\r\n            if (nums.indexOf(descrip[0]) === -1) {\r\n                // basically this is means this is a meta data about the file\r\n                subj = descrip.substr(0, descrip.indexOf(':'));\r\n                elm = descrip.substr(descrip.indexOf(':') + 1, descrip.length);\r\n                if (subj === 'au') subj = 'author';\r\n                if (subj === 'ar') subj = 'artist';\r\n                if (subj === 'al') subj = 'album';\r\n                if (subj === 'ti') subj = 'title';\r\n                sub.meta[subj] = elm;\r\n            }\r\n            else {\r\n                // means this is a lyric line\r\n                rang = this.convertToTime(descrip);\r\n                k = sub.ranges.push([rang]);\r\n                sub.subtitles.push([body]);\r\n\r\n                if (sub.ranges[k - 2] !== undefined) {\r\n                    sub.ranges[k - 2].push(rang);\r\n                }\r\n            }\r\n        }\r\n        sub.ranges[sub.ranges.length - 1].push(Infinity);\r\n\r\n        sub.count = sub.subtitles.length;\r\n        this.subs.push(sub);\r\n    },\r\n    /**\r\n     * Convert a given time in seconds to a proper format to be used in a subtitle file in this way `hh:mm:ss.xx` seperated\r\n     * by the given seperator.\r\n     * @method Subtity#convertToText\r\n     * @param {number} time \r\n     * @param {string} seperator default is `:`\r\n     * @param {string} fractionSymbol default is `.`\r\n     * @returns {string}\r\n     */\r\n    convertToText: function (time, seperator = ':', fractionSymbol = '.') {\r\n        var hours = Math.floor(time / 3600);\r\n        time = time - (hours * 3600);\r\n        var minutes = Math.floor(time / 60);\r\n        time = time - (minutes * 60);\r\n        var seconds = time.toFixed(2);\r\n        seconds = seconds.replace('.', fractionSymbol);\r\n\r\n        return hours + seperator + minutes + seperator + seconds;\r\n    },\r\n    /**\r\n     * Convert the string in time notation `hh:mm:ss` or `hh:mm:ss.xx` to real number represent time \r\n     * in seconds. used internally by the library!\r\n     * @method Subtity#convertToTime\r\n     * @param {string} time \r\n     * @returns {number}\r\n     */\r\n    convertToTime: function (time) {\r\n        var dur = 0, begin, end, hours, minutes, seconds;\r\n        var org = time.split(':');\r\n\r\n\r\n        // now parse the hours minutes and seconds\r\n        if (org.length === 3) {\r\n\r\n            // something should be done after using parseFloat function:\r\n            // we should change the `,` to `.` so the function does right parsing\r\n            // this is only in srt file\r\n            org[2] = org[2].replace(',', '.');\r\n\r\n\r\n            hours = parseFloat(org[0]);\r\n            minutes = parseFloat(org[1]);\r\n            seconds = parseFloat(org[2]);\r\n        }\r\n        else {\r\n            org[1] = org[1].replace(',', '.');\r\n\r\n\r\n            // for mm:ss.xx representation\r\n            hours = 0;\r\n            minutes = parseFloat(org[0]);\r\n            seconds = parseFloat(org[1]);\r\n        }\r\n\r\n        // then we convert all to seconds\r\n        dur += (hours * 3600) + (minutes * 60) + seconds;\r\n\r\n        return dur\r\n    },\r\n    /**\r\n     * Used internally by the class to parse a rang representation string into seconds count,\r\n     * for `srt` , `subti` , `sbv` and `webvtt` file formats.\r\n     * @method Subtity#getSeconds\r\n     * @param {string} repRang stands for representation rang\r\n     * @returns {Array}\r\n     */\r\n    getSeconds: function (repRang) {\r\n        var rang = [0, 0];\r\n        // first we seperate the rang, usually it's the form beginTime-->endTime in srt and webvtt\r\n        // files and beginTime,endTime in sbv files and beginTime=>endTime in subti files\r\n        // so we need to check the existance of the arrow, if not then we seperate with `,`\r\n        repRang = repRang.indexOf('=>') !== -1 ? repRang.split('=>') : repRang.indexOf('-->') === -1 ? repRang.split(',') : repRang.split('-->');\r\n\r\n        // using a local function we subtract time(convert it)\r\n        rang[0] = this.convertToTime(repRang[0]);\r\n        rang[1] = this.convertToTime(repRang[1]);\r\n\r\n        return rang;\r\n    },\r\n    /**\r\n     * Must be called as the video time updated or the loop updated, to render or display the subtitles.\r\n     * @method Subtity#update\r\n     */\r\n    update: function () {\r\n        if (this.mode === null) {\r\n            console.warn('Must set up the parser rendering mode first!\\`Subtity.setUp2D or Subtity.setUpContainer\\`');\r\n            return;\r\n        }\r\n\r\n        if (this.ranges.length === 0 || this.subtitles.length === 0 || this.activated === false) return;\r\n\r\n        current = this.video.currentTime * this.speedFactor;\r\n        mov = this.video.src;\r\n\r\n        for (let i = 0; i < this.ranges.length; i++) {\r\n            const rang = this.ranges[i];\r\n            const text = this.subtitles[i];\r\n            current -= this.offset;\r\n\r\n            if (current >= rang[0] && current <= rang[1]) {\r\n                this.current = i;\r\n\r\n                if (this.mode === 1) {\r\n                    this.container.innerText = this.subtitles[this.current];\r\n                }\r\n                else {\r\n                    // for rendering mode we should get the options\r\n                    family = this.style.family || 'Arial';\r\n                    style = this.style.style || 'normal';\r\n                    variant = this.style.variant || 'normal';\r\n                    base = this.style.base || 90;\r\n                    left = this.style.left || 50;\r\n                    size = this.style.size || 25;\r\n                    align = this.style.align || 'center';\r\n                    color = this.style.color || 'white';\r\n                    bg = this.style.bg || 'rgba(0,0,0,0)';\r\n                    direction = this.style.direction || 'ltr';\r\n                    opacity = this.style.opacity || 1;\r\n                    weight = this.style.weight || 'bold';\r\n                    marginL = this.style.marginLeft;\r\n                    marginT = this.style.marginTop;\r\n                    outlineColor = this.style.outlineColor || 'black';\r\n                    outlineSize = this.style.outlineSize || 1;\r\n                    shadowColor = this.style.shadowColor || 'rgba(0,0,0,0)';\r\n                    shadowX = this.style.shadowX || 0;\r\n                    shadowY = this.style.shadowY || 0;\r\n                    shadowBlur = this.style.shadowBlur || 0;\r\n                    lineSpacing = this.style.lineSpacing || 0;\r\n                    lineHeight = this.style.lineHeight;\r\n\r\n                    this.renderer.beginPath();\r\n                    x = (this.renderer.canvas.width / 100) * left;\r\n                    y = (this.renderer.canvas.height / 100) * base;\r\n\r\n                    this.renderer.fillStyle = color;\r\n                    this.renderer.textAlign = align;\r\n                    this.renderer.direction = direction;\r\n                    this.renderer.font = `${style} ${variant} ${weight} ${size}px ${family}`;\r\n                    this.renderer.shadowColor = shadowColor;\r\n                    this.renderer.shadowBlur = shadowBlur;\r\n                    this.renderer.shadowOffsetX = shadowX;\r\n                    this.renderer.shadowOffsetY = shadowY;\r\n                    this.renderer.globalAlpha = opacity;\r\n\r\n\r\n                    // we loop from end to begin to save the natural order of the subtitles\r\n                    // because we drawing from bottom to top to\r\n                    for (let j = text.length - 1; j > -1; j--) {\r\n                        const line = text[j];\r\n\r\n                        this.renderer.strokeStyle = outlineColor;\r\n                        this.renderer.lineWidth = outlineSize * 2;\r\n                        this.renderer.strokeText(line, x, y);\r\n                        this.renderer.lineWidth = 1;\r\n                        this.renderer.fillText(line, x, y);\r\n                        y -= (lineHeight + lineSpacing);\r\n                    }\r\n\r\n                    this.renderer.closePath();\r\n                }\r\n            }\r\n        }\r\n    },\r\n    /**\r\n     * Set up the parser to render the text to a 2D CanvasRendering context, passing the HTMLCanvasElement\r\n     * to render on, and optional options list of styles to be applied to the text while rendering.\r\n     * @method Subtity#setUp2D\r\n     * @param {HTMLCanvasElement} canvas the canvas element or it context\r\n     * @param {HTMLVideoElement} video \r\n     */\r\n    setUp2D: function (canvas, video) {\r\n\r\n        this.renderer = canvas instanceof CanvasRenderingContext2D ? canvas : canvas.getContext('2d');\r\n        this.mode = 2;\r\n        this.video = video;\r\n    },\r\n    /**\r\n     * Set up the parser to use an HTMLElement to display the subtitles, passing the HTMLElement!\r\n     * @method Subtity#setUpContainer\r\n     * @param {HTMLElement} elm \r\n     * @param {HTMLVideoElement} video \r\n     */\r\n    setUpContainer: function (elm, video) {\r\n        this.container = elm;\r\n        this.mode = 1;\r\n        this.video = video;\r\n    },\r\n    /**\r\n     * Set the offset value, pass positive number to progress or negative to delay the subtitle displaying process.\r\n     * @method Subtity#setOffset\r\n     * @param {number} offset \r\n     */\r\n    setOffset: function (offset) {\r\n        this.offset = typeof offset === 'number' && !isNaN(offset) ? offset : this.offset;\r\n    },\r\n    /**\r\n     * Change the subtitle rendering speed\r\n     * @method Subtity#setSpeed\r\n     * @param {number} speed \r\n     */\r\n    setSpeed: function (speed) {\r\n        this.speedFactor = typeof speed === 'number' && !isNaN(speed) ? speed : this.speedFactor;\r\n    },\r\n    /**\r\n     * Customize the subtitles style when displaying, this is only applied when rendering\r\n     * to a 2D context, not when using normal DOM element.\r\n     * @method Subtity#set\r\n     * @param {string} style \r\n     * @param {any} value \r\n     */\r\n    set: function (style, value) {\r\n\r\n        switch (style) {\r\n            case 'family':\r\n                this.style.family = value;\r\n                this.calcFontHeight();\r\n                break;\r\n            case 'color':\r\n                this.style.color = value;\r\n                break;\r\n            case 'weight':\r\n                this.style.weight = value;\r\n                break;\r\n            case 'style':\r\n                this.style.style = value;\r\n                break;\r\n            case 'variant':\r\n                this.style.variant = value;\r\n                break;\r\n            case 'size':\r\n                this.style.size = parseFloat(value);\r\n                this.calcFontHeight();\r\n                break;\r\n            case 'align':\r\n                this.style.align = value;\r\n                break;\r\n            case 'direction':\r\n                this.style.direction = value;\r\n                break;\r\n            case 'shawX':\r\n                this.style.shadowX = parseFloat(value);\r\n                break;\r\n            case 'shawY':\r\n                this.style.shadowY = parseFloat(value);\r\n                break;\r\n            case 'shawBlur':\r\n                this.style.shadowBlur = value;\r\n                break;\r\n            case 'shawColor':\r\n                this.style.shadowColor = value;\r\n                break;\r\n            case 'bg':\r\n                this.style.bg = value;\r\n                break;\r\n            case 'outlineColor':\r\n                this.style.outlineColor = value;\r\n                break;\r\n            case 'outlineSize':\r\n                this.style.outlineSize = parseFloat(value);\r\n                break;\r\n            case 'lineSpacing':\r\n                this.style.lineSpacing = parseFloat(value);\r\n                break;\r\n            case 'base':\r\n                this.style.base = parseFloat(value);\r\n                break;\r\n            case 'left':\r\n                this.style.left = parseFloat(value);\r\n                break;\r\n            case 'opacity':\r\n                this.style.opacity = isNaN(parseFloat(value)) ? 1 : parseFloat(value);\r\n\r\n        }\r\n    },\r\n    /**\r\n     * Used internally by the engine to calculate the font height currently under use\r\n     * @method Subtity#calcFontHeight\r\n     * @returns {number}\r\n     */\r\n    calcFontHeight: function () {\r\n        fontSize = parseFloat(this.style.size);\r\n        fontFamily = this.style.family;\r\n\r\n        var modal = 'gM';\r\n        var context = this.ctx;\r\n        context.canvas.width = context.canvas.width;\r\n\r\n        context.fillRect(0, 0, context.canvas.width, context.canvas.height);\r\n        context.textBaseline = 'top';\r\n\r\n        context.font = fontSize + 'px ' + fontFamily;\r\n        context.fillStyle = 'white';\r\n\r\n        context.fillText(modal, 0, 0);\r\n\r\n        var data = context.getImageData(0, 0, context.canvas.width, context.canvas.height).data;\r\n\r\n        var start = -1;\r\n        var end = -1;\r\n        for (var i = 0; i < context.canvas.height; i++) {\r\n\r\n            for (var j = 0; j < context.canvas.width; j++) {\r\n                var index = (i * context.canvas.width + j) * 4;\r\n\r\n                if (data[index] === 0) {\r\n                    if (j === context.canvas.width - 1 && start !== -1) {\r\n                        end = i;\r\n                        i = context.canvas.height;\r\n                        break\r\n                    }\r\n                    continue\r\n                }\r\n                else {\r\n                    if (start === -1) {\r\n                        start = i;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.style.lineHeight = end - start;\r\n    },\r\n    /**\r\n     * Loads the default style applied to the rendering process\r\n     * @method Subtity#loadDefaultStyle\r\n     */\r\n    loadDefaultStyle: function () {\r\n        this.style = {\r\n            family: 'Arial',\r\n            size: 19,\r\n            lineSpacing: 10,\r\n            color: 'rgb(255,255,255)',\r\n            align: 'center',\r\n            direction: 'ltr',\r\n            outlineColor: 'rgb(0,0,0)',\r\n            outlineSize: 1,\r\n            shadowColor: 'rgba(0,0,0,0)',\r\n            opacity: 1,\r\n            shadowBlur: 0,\r\n            shadowX: 0,\r\n            shadowY: 0,\r\n            base: 90,\r\n            left: 50,\r\n            weight: '',\r\n            style: 'normal',\r\n            variant: 'normal'\r\n        }\r\n    },\r\n    /**\r\n     * Toggle the activation of the subtitle\r\n     * @method Subtity#toggleActivation\r\n     * @param {boolean} state the state to force applying `false` to disactivate or `true` to activate.\r\n     * @returns {boolean} the new activation state\r\n     */\r\n    toggleActivation: function (state) {\r\n        if (typeof state === 'boolean') {\r\n            this.activated = state;\r\n        }\r\n        else {\r\n            this.activated = !this.activated;\r\n        }\r\n        return this.activated;\r\n    },\r\n    /**\r\n     * Remove a subtitle from the list\r\n     * @method Subtity#remove\r\n     * @param {string} title \r\n     * @returns {object} the removed subtitle or false if it was not found\r\n     */\r\n    remove: function (title) {\r\n        var i = this.subs.findIndex(a => a.title === title);\r\n\r\n        if (i !== -1) {\r\n            if (this.subs[i].used === true) {\r\n                this.reset();\r\n            }\r\n            return this.subs.splice(i, 1);\r\n        }\r\n        return false\r\n    },\r\n    /**\r\n     * Add a new subtitle to the list\r\n     * @method Subtity#add\r\n     * @param {string} title the subtitle special title to use it later\r\n     * @param {string} text the subtitle file text content\r\n     * @param {string} ext the extension of the subtitle\r\n     * @param {string} movie the name of the movie this subtitle going to be used with\r\n     */\r\n    add: function (title, text, ext, movie) {\r\n        if (typeof ext !== 'string' || typeof text !== 'string' || title === '') return;\r\n\r\n        var res = this.check(title);\r\n        if (res === false) {\r\n            return;\r\n        }\r\n\r\n        ext = ext.toLowerCase();\r\n        if (ext === '.srt' || ext === 'srt') {\r\n            this.parseSRT(text, title, movie);\r\n        }\r\n        else if (ext === '.sbv' || ext === 'sbv') {\r\n            this.parseSBV(text, title, movie);\r\n        }\r\n        else if (ext === '.itt' || ext === 'itt') {\r\n            this.parseITT(text, title, movie);\r\n        }\r\n        else if (ext === '.webvtt' || ext === 'webvtt') {\r\n            this.parseWEBVTT(text, title, movie);\r\n        }\r\n        else if (ext === '.ssa' || ext === 'ssa') {\r\n            this.parseSSA(text, title, movie);\r\n        }\r\n        else if (ext === '.usf' || ext === 'usf') {\r\n            this.parseUSF(text, title, movie);\r\n        }\r\n        else if (ext === '.lrc' || ext === 'lrc') {\r\n            this.parseLRC(text, title, movie);\r\n        }\r\n        else if (ext === '.subti' || ext === 'subti') {\r\n            this.parseSUBTI(text, title, movie);\r\n        }\r\n        else if (ext === '.rt' || ext === 'rt') {\r\n            this.parseRT(text, title, movie);\r\n        }\r\n        else if (ext === '.dfxp' || ext === 'dfxp' || ext === 'ttml' || ext === '.ttml') {\r\n            this.parseXMLBased(text, title, movie);\r\n        }\r\n        else if (ext === '.xml' || ext === 'xml') {\r\n            this.parseXML(text, title, movie);\r\n        }\r\n    },\r\n    /**\r\n     * Export the current system stored subtitles into a file text in certain type\r\n     * @method Subtity#export\r\n     * @param {string} fileFormat \r\n     * @returns {string} the text content or `false` if cannot export to the given type/fileFormat\r\n     */\r\n    export: function (fileFormat) {\r\n        if (typeof fileFormat !== 'string') return;\r\n\r\n        fileFormat = fileFormat.toLowerCase();\r\n        var text = false;\r\n\r\n        if (fileFormat === '.srt' || fileFormat === 'srt') {\r\n            text = this.exportToSRT();\r\n        }\r\n        else if (fileFormat === '.sbv' || fileFormat === 'sbv') {\r\n            // to be done\r\n        }\r\n        else if (fileFormat === '.itt' || fileFormat === 'itt') {\r\n            // ti be done\r\n        }\r\n        else if (fileFormat === '.webvtt' || fileFormat === 'webvtt') {\r\n            text = this.exportToWEBVTT();\r\n        }\r\n        else if (fileFormat === '.ssa' || fileFormat === 'ssa') {\r\n            text = this.exportToSSA();\r\n        }\r\n        else if (fileFormat === '.usf' || fileFormat === 'usf') {\r\n            // to be done\r\n        }\r\n        else if (fileFormat === '.lrc' || fileFormat === 'lrc') {\r\n            text = this.exportToLRC();\r\n        }\r\n        else if (fileFormat === '.subti' || fileFormat === 'subti') {\r\n            text = this.exportToSUBTI();\r\n        }\r\n\r\n        return text\r\n    },\r\n    /**\r\n     * Check whether a title is under use or not, then warn to console if it's is\r\n     * @method Subtity#check\r\n     * @param {string} title\r\n     * @returns {boolean}\r\n     */\r\n    check: function (title) {\r\n        var index = this.subs.findIndex(a => a.title === title);\r\n        if (index !== -1) {\r\n            console.warn('The given title( ' + title + ') is already under use, please use a new one');\r\n            return false;\r\n        }\r\n        return true;\r\n    },\r\n    /**\r\n     * Export the current system content of subtitles and ranges to an .srt file formats text\r\n     * @method Subtity#exportToSRT\r\n     * @returns {string}\r\n     */\r\n    exportToSRT: function () {\r\n        var text = '';\r\n        for (let i = 0; i < this.subtitles.length; i++) {\r\n            const sub = this.subtitles[i];\r\n            const rang = this.ranges[i];\r\n            var sect = (i + 1) + '\\n';\r\n            sect += this.convertToText(rang[0], ':', ',') + ' --> ' + this.convertToText(rang[1], ':', ',') + '\\n';\r\n\r\n            sect += sub.join('\\n');\r\n\r\n            text += sect + '\\n';\r\n        }\r\n\r\n        return text;\r\n    },\r\n    /**\r\n     * Export the current system content of subtitles and ranges to an .webvtt file formats text\r\n     * @method Subtity#exportToWEBVTT\r\n     * @returns {string}\r\n     */\r\n    exportToWEBVTT: function () {\r\n        var text = 'WEBVTT\\n';\r\n\r\n        for (let i = 0; i < this.subtitles.length; i++) {\r\n            const sub = this.subtitles[i];\r\n            const rang = this.ranges[i];\r\n            var sect = (i + 1) + '\\n';\r\n            sect += this.convertToText(rang[0]) + ' --> ' + this.convertToText(rang[1]) + '\\n';\r\n\r\n            sect += sub.join('\\n');\r\n\r\n            text += sect + '\\n';\r\n        }\r\n\r\n        return text;\r\n    },\r\n    /**\r\n     * Export the current system content of subtitles and ranges to an .subti file formats text\r\n     * @method Subtity#exportToSUBTI\r\n     * @returns {string}\r\n     */\r\n    exportToSUBTI: function () {\r\n        var text = '';\r\n\r\n        // inserting the meta data first\r\n        for (const key in this.meta) {\r\n            if (this.meta.hasOwnProperty(key)) {\r\n                const element = this.meta[key];\r\n                s = key + ' = ' + element + '\\n';\r\n                text += s;\r\n            }\r\n        }\r\n        text += '==';\r\n        var names = this.meta.names !== undefined ? this.meta.names : [];\r\n\r\n        // now inserting the subtitles\r\n        for (let i = 0; i < this.subtitles.length; i++) {\r\n            const subtitle = this.subtitles[i];\r\n            const rang = this.ranges[i];\r\n            const name = names[i] !== undefined ? names[i] : '';\r\n\r\n            var sect = name + '\\n';\r\n            sect += this.convertToText(rang[0]) + '=>' + this.convertToText(rang[1]) + '\\n';\r\n\r\n            sect += subtitle.join('\\n');\r\n\r\n            text += sect + '\\n==';\r\n        }\r\n\r\n        return text\r\n    },\r\n    /**\r\n     * Export the current system content of subtitles and ranges to an .lrc file formats text\r\n     * @method Subtity#exportToLRC\r\n     * @returns {string}\r\n     */\r\n    exportToLRC: function () {\r\n        var text = '';\r\n        // first packaging the meta data\r\n        for (const key in this.meta) {\r\n            if (this.meta.hasOwnProperty(key)) {\r\n                const value = this.meta[key];\r\n                name = key === 'artist' ? 'ar' : key === 'album' ? 'al' : key === 'title' ? 'ti' : key === 'author' ? 'au' : key;\r\n                text += '[' + name + ':' + value + ']\\n';\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this.subtitles.length; i++) {\r\n            const sub = this.subtitles[i][0];\r\n            const rang = this.convertToText(this.ranges[i][0]);\r\n            text += '[' + rang + ']' + sub + '\\n';\r\n        }\r\n\r\n        return text;\r\n    },\r\n    /**\r\n     * Export the current system content of subtitles and ranges to an .ssa file formats text\r\n     * @method Subtity#exportToSSA\r\n     * @returns {string}\r\n     */\r\n    exportToSSA: function () {\r\n        text = '[Script Info]\\n';\r\n        // packaging the meta data\r\n        for (const key in this.meta) {\r\n            if (this.meta.hasOwnProperty(key)) {\r\n                const element = this.meta[key];\r\n                text += key + ': ' + element + '\\n';\r\n            }\r\n        }\r\n        text += '\\n';\r\n\r\n        // now the subtitle\r\n        text += '[Events]\\n';\r\n        // declaring the format\r\n        text += 'Format: Start, End, Name, Text\\n';\r\n        var names = this.meta.names !== undefined ? this.meta.names : [];\r\n\r\n        for (let i = 0; i < this.subtitles.length; i++) {\r\n            const sub = this.subtitles[i];\r\n            const rang1 = this.convertToText(this.ranges[i][0]);\r\n            const rang2 = this.convertToText(this.ranges[i][1]);\r\n            const name = names[i] !== undefined ? names[i] : 'Unknown';\r\n\r\n            text += 'Dialogue: ' + rang1 + ',' + rang2 + ',' + name + ',' + sub + '\\n';\r\n        }\r\n\r\n        return text\r\n    },\r\n    /**\r\n     * Change the current subtitle language if subtitle file provided with multi languages, this is only supported with certain\r\n     * file formats like `.dfxp`.\r\n     * @method Subtity#switchToLang\r\n     * @param {string} lang the first two letter of the language for example for `english` you pass `en` and so on... \r\n     */\r\n    switchToLang: function (lang) {\r\n        if (this.meta.langs !== undefined) {\r\n            if (this.meta.langs.hasOwnProperty(lang)) {\r\n                this.subtitles = this.meta.langs[lang];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default Subtity;"],"names":["nums","Subtity","this","subs","title","text","subtitles","ranges","current","subtitlesCounts","offset","style","family","size","lineSpacing","variant","color","align","direction","outlineColor","outlineSize","shadowColor","opacity","shadowBlur","shadowX","shadowY","base","left","weight","renderer","container","meta","mode","video","ctx","document","createElement","getContext","activated","currentFileType","speedFactor","prototype","reset","use","i","findIndex","a","j","used","count","type","calcFontHeight","parseSRT","movie","sections","split","sub","isNam","subtitle","length","line","push","indexOf","getSeconds","parseXMLBased","langs","lang","rang","flang","rangout","element","undefined","keyword","substr","forEach","replaceAll","lines","k","convertToTime","parseXML","pop","section","rang0","replace","rang1","parseWEBVTT","openSection","parseSBV","data","off","two","parseSSA","syntax","toLowerCase","pieces","splice","lineSubject","lineBody","lineBodySections","trim","string","i0","i1","t1","t2","parseRT","shift","prop","config","parseFloat","parseITT","timeRang","raw","betterText","sect","parseUSF","fline","sline","ino","splitter","date","authorData","authorName","authorUrl","authorEmail","language","t","begin","end","alr","concat","parseSUBTI","names","parseLRC","descrip","body","subj","elm","Infinity","convertToText","time","seperator","fractionSymbol","hours","Math","floor","minutes","seconds","toFixed","dur","org","repRang","update","currentTime","mov","src","innerText","bg","marginL","marginLeft","marginT","marginTop","lineHeight","beginPath","x","canvas","width","y","height","fillStyle","textAlign","font","shadowOffsetX","shadowOffsetY","globalAlpha","strokeStyle","lineWidth","strokeText","fillText","closePath","console","warn","setUp2D","CanvasRenderingContext2D","setUpContainer","setOffset","isNaN","setSpeed","speed","set","value","fontSize","fontFamily","context","fillRect","textBaseline","getImageData","start","loadDefaultStyle","toggleActivation","state","remove","add","ext","check","export","fileFormat","exportToSRT","exportToWEBVTT","exportToSSA","exportToLRC","exportToSUBTI","join","key","hasOwnProperty","s","name","rang2","switchToLang"],"mappings":"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"}